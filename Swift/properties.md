2022-02-22

---
프로퍼티는 클래스, 구조체, 열거형과 관련있는 값이다. 

**저장 프로퍼티(Stored Property)**

- 값을 저장하는 프로퍼티

- 클래스, 구조체에서만 사용 가능

- 구조체를 상수(`let`)로 선언하면 구조체 내부의 프로퍼티가 `var`로 선언되었다 하더라도 프로퍼티 값 변경이 불가하다.

- **Lazy stored property** 

   ㄴ “lazy”는 일단 선언만 해놓고 실제 사용할 때 초기화하는 것. `var` 와 함께 쓰여야 한다. 

   ㄴ 프로퍼티가 특정 요소에 의존적이어서 그 요소가 끝나기 전까지는 적절한 값을 알지 못하는 경우에 유용하다.

       복잡한 계산이나 부하가 많이 걸리는 작업일 경우 lazy를 이용하면 좋다.

**계산 프로퍼티(Computed Property)**

- 값 저장하지 않음. 프로그래밍된 대로 값을 계산해서 반환(`get`)하거나 다른 프로퍼티의 값을 세팅(`set - optional`)하는 프로퍼티.

- 클래스, 구조체, 열거형 모두 사용 가능

- 계산 프로퍼티 선언 시에는 반드시 `var`를 이용해야함. 왜냐하면 계산값에 따라 값이 변할 수 있기 때문임.

- setter 선언 시 별도로 새로운 값에 대한 이름을 지정하지 않으면 기본적으로 `newValue`가 새로운 값을 참조하는 키워드다.

- read-only computed property : getter만 있고 setter는 지정되지 않은 계산 프로퍼티

**프로퍼티 옵저버(Property Observer)**

- 프로퍼티는 새로운 값이 설정될 때마다 이 이벤트를 감지하는 옵저버를 제공한다. 이것이 프로퍼티 옵저버임. 

- 새 값과 이전값이 같아도 항상 호출됨.

- lazy stored property에서는 옵저버를 사용할 수 없다.

- 계산 프로퍼티는 setter에서 값의 변화를 감지할 수 있기 때문에 따로 옵저버를 정의할 필요 없음

- `willSet` : 값이 저장되기 바로 직전에 호출됨. 새로운 값은 `newValue`로 참조 가능

- `didSet` : 값이 저장된 직후 호출됨. 이전 값은 `oldValue`로 참조 가능

- 만약 in-out 파라미터로 선언된 함수의 인자에 프로퍼티를 넘기면 `willSet`과 `didSet`이 항상 실행됩니다. 이유는 in-out 파라미터이기 때문에 프로퍼티가 항상 복사(copy)되기 때문입니다. 이 in-out 파라미터의 프로퍼티는 항상 원래 값에 새 값을 다시 덮어쓰게 됩니다.

**타입 프로퍼티**

- 인스턴스 프로퍼티는 특정 인스턴스에 속한 프로퍼티를 말한다.

- 타입 프로퍼티는 특정 타입에 속한 프로퍼티로, 인스턴스화하지 않아도 접근할 수 있는 프로퍼티다. 

- `static` 키워드를 사용한다.

  클래스는 `static`과 `class` 두가지를 키워드로 사용할 수 있다.

  static - 서브클래스에서 overriding 불가

  class - 서브클래스에서 overriding 가능