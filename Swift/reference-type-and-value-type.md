class와 structure의 차이를 어떻게 설명할 수 있을까 고민해봤음.   
외우는 것도 좋지만, 기억에 오래 남기기 위해서는 궁극적으로 이해가 필요하고 나만의 정리 흐름이 필요하다는 것을 다시한번 느끼게 됐음.   

아무튼 오늘은 class와 structure의 차이에 대해 다시한번 정리해봤음.
## class와 structure의 차이
1. 참조 타입 or 값 타입    
2. 상속 가능 여부   

이 두가지 차이에서 파생되는(공부할 수 있는) 것들은 아래와 같다.
- 깊은 복사와 얕은 복사
- heap 할당과 stack 할당
- reference counting 실행 여부
- 정적 디스패치와 동적 디스패치

### 깊은 복사와 얕은 복사
🔗 [깊은 복사 vs 얕은 복사](https://velog.io/@ellyheetov/Shallow-Copy-VS-Deep-Copy)   

#### 무엇을 배웠나?
- 나는 얕은 복사와 깊은 복사의 개념을 반대로 이해하고 있었음.   
    - 참조 타입은 새로운 변수에 이미 만들어진 인스턴스를 할당할 때 인스턴스 전체 값이 아닌, 인스턴스가 위치하고 있는 메모리 주소 값이 할당된다. 이를 "얕은 복사"라고 한다.
    - 값 자체가 복사되는 것은 "깊은 복사"라고 하며 swift에서는 structure, enum 등이 이에 해당된다.

- class도 깊은 복사를 할 수 있다는 걸 알게됨.
    - NSCopying 프로토콜을 채택하고 구현하면 `someClass.copy()`를 이용해 깊은 복사를 할 수 있다.

- structure도 얕은 복사를 할 수 있나?
    - 내가 아는 방법은 두가지가 있다. 하나는 inout 변수를 활용하는 것이고 다른 하나는 클로저의 캡처링을 사용하는 방법이다. (또한 오늘을 기점으로 COW도 있다는 것을 알게됨)
    - 이 외의 방법을 검색해봤으나 그렇게 잘 나오지는 않았다. 어쩌면 검색키워드를 잘못 잡은 것일 수도 있겠다.   
    (swift structure shallow copy, swift structure 얕은 복사 등으로 검색해봤음.)
    - 그리고 이걸 보다보니 궁금한게 생겼음. "얕은 복사가 필요했다면 그냥 class로 만드는게 낫지 않을까?" 하는 것이었다.
    - 나는 iOS 개발자가 아주아주 많은 오픈채팅방에 참여하고 있는데 거기에 다음과 같이 질문했다.
        > 값 타입과 참조 타입에 대해 공부하고 있는데 혹시 structure도 얕은 복사를 할 수 있는 방법이 있을까요? 
함수의 매개변수로 inout 사용하거나 클로저의 캡처링을 이용하면 structure라 하더라도 얕은 복사가 가능하다고 알고 있는데 이외에 다른 방법이 있을까요?
또한 애초에 얕은 복사가 필요했다면 그냥 class로 만드는게 더 나을 것 같은데 해당 부분에 대한 다른 분들의 의견도 궁금합니다!

    - 그리고 이에 대한 답변을 받았는데 (내가 이해하기로는) 다음과 같다.   
    👉 복사하는게 클 때가 있기 때문에 structure에도 얕은 복사가 필요하다.   
    👉 COW에 대해 공부해보세요!
    - 첫번째 답변을 이해하기까지 상당한 시간이 소요됐다.
    나는 이제까지 structure가 복사되면 무조건 COW가 적용되는 줄 알았다. 그래서 첫번째 답변을 보고 오히려 더 혼란스러웠다. 하지만 COW에 대해 좀 더 찾아보고 내 전제가 잘못됐음을 알 수 있게 됐다.
        > [ 나의 전제 ]   
        Structure는 무조건 COW 최적화가 적용되어 있다.   

        > [ 실제 사실 ]   
        swift에서 제공해주는 standard library 이외에는 COW가 자동으로 적용되지 않는다. 커스텀 structure를 정의한다면 별도로 구현해야 한다.   
    🔗  [Use Copy-On-Write With Swift Value Types](https://www.marcosantadev.com/copy-write-swift-value-types/)

    - 🤭 *새로운 사실을 알았다.* 
    - structure를 쓰냐 class를 쓰냐는 또 다른 문제다. 다만, 얕은 복사를 사용하기 위해 class를 쓰는 것은 적절한 기준이 아니다.
    - 재미따 혼란스럽지만 그게 정리되고 나면 진짜 공부가 재밌고 그렇다. 아주 찰나의 순간이지만..😅


아래부터는 [스위프트 성능 이해하기 (1) - struct와 class의 성능차이](https://corykim0829.github.io/swift/Understanding-Swift-Performance/#)를 읽은 후 알게 된 것들을 정리한 것이다.

### Heap에 저장된다는 것, Stack에 저장된다는 것
#### 무엇을 배웠나?
✓ 내가 알고 있던 것
- 참조 타입은 heap에 저장되고 값이 저장된 메모리 주소는 stack에 저장된다.
- 참조 타입의 메모리 해제는 reference counting을 통해 관리되어진다.
- structure에 참조 타입 프로퍼티가 두 개 이상있으면 성능상 좋지 않다.

✓ 새롭게 알게 된 것
- heap과 stack의 차이
    - stack은 LIFO이기 때문에 가장 상단에(가장 마지막에) 차곡차곡 데이터를 저장한다.  
    - heap은 빈 메모리 공간을 찾아서 값을 저장하기 때문에 stack에 메모리 공간 상 주소를 저장하고 이를 참조해야 한다.

- "원자적"이라는 의미   
🔗 [원자적으로? - atomically](https://opentutorials.org/course/1724/9839)
    - “원자”라는건 물리학에서 더 이상 쪼갤 수 없는 단위를 말함.
    - 프로그래밍에서 “원자적"이라는 것은 어떤 작업 단위가 더 이상 쪼갤 수 없는 단위라는 의미이다.
    - 예를 들어 작업 단위가 A, B로 이루어져있을 때 A는 성공, B는 실패하면 해당 작업단위는 실패한 것으로 보는 것임. 둘다 성공해야 성공임.
### reference counting 실행 여부
- String은 reference counting이 발생한다.
    - String은 value type이지만 내부적으로 Character의 배열로 이루어져있고, 이는 Heap에 할당되기 때문에 필연적으로 reference counting이 발생하게 된다.
    - 따라서 structure의 프로퍼티로 String을 여러개 가지고 있다면, 오히려 class보다 성능 상 좋지 않을 수 있다.
    - "structure는 무조건 reference counting이 발생하지 않는다"는 것은 잘못된 사실이다.

### 정적 디스패치와 동적 디스패치
- "디스패치"라는 것은 어떤 메소드를 실행할지를 결정하고 이를 호출하는 과정을 말한다. 어떤 메소드인지 결정되는 시점에 따라 정적 디스패치인지, 동적 디스패치인지 나뉘어진다.
- 정적 디스패치 : 컴파일 시점에 어디서 메소드를 가져올지 컴파일러가 이미 알고 있는 것.
- 동적 디스패치 : 컴파일 시점에는 모르기 때문에 런타임에 동적으로 어떤 메소드를 실행할지 결정하는 것.
- structure나 enum과 같은 value type은 정적 디스패치가 실행된다. 왜냐면 상속을 할 수 없기 때문임.
- class는 상속이 가능하기 때문에 기본적으로 동적 디스패치로 실행할 메소드의 메모리 주소를 알게 된다. class도 정적 디스패치를 사용하도록 만들 수 있는데 이게 곧 (내가 이해하기론) class의 성능을 높이는 방법이 된다. final, private, WMO(Whole Module Optimization)이 있음.
