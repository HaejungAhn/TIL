2022-02-21

---
## **ë°˜ë³µë¬¸**

í‚¤ì›Œë“œ - while, for-in

### for-in

- ë£¨í”„ë¥¼ ì§„í–‰í•  **ë²”ìœ„ë¥¼ ì§€ì •í•¨**
- Sequence í”„ë¡œí† ì½œì„ ì¤€ìˆ˜í•˜ë©´ ì´ êµ¬ë¬¸ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ.
- ì‚¬ìš© ê°€ëŠ¥í•œ íƒ€ì… - ë°°ì—´, ë”•ì…”ë„ˆë¦¬, set, ìˆ«ì ë²”ìœ„ ì—°ì‚°ì(ex. 1<..4), ë¬¸ìì—´ ë“±

```swift
// ìˆ«ìë²”ìœ„ ì—°ì‚°ì
for i in 1...4 {
	print(i) 
}
// 1, 2, 3, 4

// set : ìˆœì„œ ì—†ì´ ë¬´ì‘ìœ„ë¡œ ë‚˜ì˜´
let numbers: Set<Int> = [1, 2, 5, 7, 10]
for num in numbers {
	print(num)
}

// ë”•ì…”ë„ˆë¦¬ : ìˆœì„œ ì—†ì´ ë¬´ì‘ìœ„ë¡œ ë‚˜ì˜´
let numbers: [String: Int] = ["one": 1, "two": 2, "three": 3]
for (k, v) in numbers {
    print("\(k) - \(v)")
}
```

- ë²”ìœ„ì— ì‚¬ìš©ê°€ëŠ¥í•œ í•¨ìˆ˜;

`stride(from:to:by:)` í•¨ìˆ˜ëŠ” `by`ë¡œ ì§€ì •ëœ ê°’ë§Œí¼ ì ì§„ì ìœ¼ë¡œ ê°’ì„ ì¦ê°€ì‹œí‚¤ë©´ì„œ `from`ê°’ë¶€í„° `to`ê°’ê¹Œì§€ì˜ ì‹œí€€ìŠ¤ë¥¼ ë¦¬í„´í•œë‹¤.  (ë‹¨, **ë§ˆì§€ë§‰ ê°’ì€ í¬í•¨í•˜ì§€ ì•ŠìŒ**)

`stride(from:through:by:)` í•¨ìˆ˜ëŠ” `by`ë¡œ ì§€ì •ëœ ê°’ë§Œí¼ ì ì§„ì ìœ¼ë¡œ ê°’ì„ ì¦ê°€ì‹œí‚¤ë©´ì„œ `from`ê°’ë¶€í„° `through`ê°’ê¹Œì§€ì˜ ì‹œí€€ìŠ¤ë¥¼ ë¦¬í„´í•œë‹¤. (ë‹¨, **ë§ˆì§€ë§‰ ê°’ í¬í•¨í•¨**)

```swift
let minutes = 60
let minuteInterval = 5

for tickMark in stride(from: 0, to: minutes, by: minuteInterval) {
	// render the tick mark every 5 minutes (0, 5, 10, 15 ... 45, 50, 55)
}

let hours = 12
let hourInterval = 3
for tickMark in stride(from: 3, through: hours, by: hourInterval) {
    // render the tick mark every 3 hours (3, 6, 9, 12)
}
```

### While

- **ì¡°ê±´ì„ ì§€ì •í•˜ê³  ì´ ì¡°ê±´ì´ falseê°€ ë  ë•Œê¹Œì§€ ë£¨í”„ë¥¼ ì§„í–‰í•¨**
- ë°˜ë³µë¬¸ì˜ ë²”ìœ„ë¥¼ íŠ¹ì •í•˜ê¸° ì–´ë ¤ìš¸ ê²½ìš° ì‚¬ìš©í•˜ë©´ ì¢‹ìŒ
- ì¡°ê±´ì„ ì–´ëŠ ì‹œì ì— ì²´í¬í•˜ëŠëƒë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë‘ê°€ì§€ ì¢…ë¥˜ê°€ ìˆë‹¤.
    
    `while` ë°˜ë³µ ì‹œì‘í•  ë•Œ ì¡°ê±´ ë¹„êµ
    
    `repeat-while` ë°˜ë³µ ì¢…ë£Œë  ë•Œ ì¡°ê±´ ë¹„êµ
    

```swift
let maximumNum = 20
var num = 0

while num < maximumNum { /// ì‹œì‘í•  ë•Œ ì¡°ê±´ë¬¸ ì²´í‚¹, trueì¼ ê²½ìš° whileë¬¸ body ì§„í–‰
    num += 5
    print(num)
}

num = 0
repeat { /// ì¼ë‹¨ body ì§„í–‰
    num += 20
    print(num)
} while num < 100 /// whileë¬¸ ì¢…ë£Œí•  ë•Œ ì¡°ê±´ë¬¸ ì²´í‚¹, trueì¼ ê²½ìš° ë‹¤ì‹œ whileë¬¸ body ì§„í–‰
```

# ì¡°ê±´ë¬¸

### if

- ì¡°ê±´ì´ ì ì„ ë•Œ ì í•©í•¨

### switch

- **íŒ¨í„´ì´ ì¼ì¹˜í•  ë•Œ**ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì¡°ê±´ì„ ë‚˜ëˆŒ ìˆ˜ ìˆìŒ(ë‹¨, ì²«ë²ˆì§¸ë¡œ ì¼ì¹˜í•˜ëŠ” íŒ¨í„´ì„ íƒ)
    
    ì¡°ê±´ì´ ì•„ë‹ˆë¼ â€œíŒ¨í„´"ì„ caseì— ë„£ì–´ì•¼ í•œë‹¤!!
    
- ê²€ì‚¬í•  ê°’ì˜ íƒ€ì…ê³¼ ì¡°ê±´ìœ¼ë¡œ ì‚¬ìš©ë  ê°’ì˜ íƒ€ì…ì´ ì¼ì¹˜í•´ì•¼í•œë‹¤.
- ëª…ì‹œì ìœ¼ë¡œ breakë¥¼ ê¸°ì…í•˜ì§€ ì•Šë”ë¼ë„ ì²˜ìŒ ì¼ì¹˜í•˜ëŠ” ì¡°ê±´ì„ ë§Œë‚˜ë©´ ë°”ë¡œ switchë¬¸ì´ ì¢…ë£Œëœë‹¤. ì‹¤ìˆ˜ë¡œ switch ë¬¸ì´ ì¤‘ë³µìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ” ê²½ìš°ë„ ìˆëŠ”ë°(breakë¥¼ ëª…ì‹œì ìœ¼ë¡œ ê¸°ì…í•˜ì§€ ì•Šì•„ì„œ) ì´ëŸ° ë¬¸ì œë¥¼ ë°©ì§€í•˜ê³ ì ì´ë ‡ê²Œ ë§Œë“¤ì—ˆë‹¤ê³  í•œë‹¤.
- ë§Œì•½ ì²«ë²ˆì§¸ ì¼€ì´ìŠ¤ë¥¼ ì‹¤í–‰í•˜ê³  ë‚œ ë’¤ ë‹¤ìŒ ì¼€ì´ìŠ¤ë„ ì‹¤í–‰ì‹œí‚¤ê³  ì‹¶ì„ ê²½ìš° `fallthrough` í‚¤ì›Œë“œë¡œ í‘œì‹œí•´ì¤˜ì•¼í•¨.
- switchì˜ ì¼€ì´ìŠ¤ì—ëŠ” ë²”ìœ„ì—°ì‚°ìë¥¼ ì§€ì •í•  ìˆ˜ë„ ìˆë‹¤.

```swift
let char = "a"

switch char {
// ì•„ë˜ ì¼€ì´ìŠ¤ëŠ” ì˜¤ë¥˜ ë°œìƒí•¨. ì™œëƒí•˜ë©´ ê²°ê³¼ê°’ì˜ íƒ€ì…ê³¼ charì˜ íƒ€ì…ì´ ì¼ì¹˜í•˜ì§€ ì•Šê¸° ë•Œë¬¸
// Expression pattern of type 'Bool' cannot match values of type 'String'
//case char == "a":
//    print("char is a")
case "a":
    print("char is 'a'")
    // ì´ê²Œ ì—†ìœ¼ë©´ "char is 'A'" í”„ë¦°íŠ¸ì•ˆë¨. ê·¼ë° fallthroughëŠ” ë¬´ì¡°ê±´ ë‹¤ìŒ case ì‹¤í–‰í•˜ëŠ”ë“¯?
    // íŒ¨í„´ì´ ì¼ì¹˜í•˜ë˜ ì¼ì¹˜í•˜ì§€ ì•Šë˜? ã…‡ã…‡ ë§ìŒ. ë‹¤ìŒ caseì—ì„œ ì¡°ê±´ í™•ì¸í•˜ì§€ ì•ŠìŒ.
    fallthrough 
case "A":
    print("char is 'A'")
case "a"..."z":
		print("char is between 'a' and 'z'")
default:
    print("there is no match case")
}
//char is 'a'
//char is 'A'
```

- switchì˜ caseë¡œ íŠœí”Œì„ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŒ. ë‹¨, ê²€ì‚¬í•  ê°’ë„ íŠœí”Œí˜•íƒœì—¬ì•¼ í•¨.

íŠœí”Œì—ëŠ” ê°’, ë²”ìœ„ì—°ì‚°ìë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆê³  ì–¸ë”ë°”ë¥¼ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŒ.

```swift
let somePoint = (1, 1)

switch somePoint {
case (0, 0):
    print("\(somePoint) is at the origin")
case (_, 0):
    print("\(somePoint) is on the x-axis")
case (0, _):
    print("\(somePoint) is on the y-axis")
case (-2...2, -2...2):
    print("\(somePoint) is inside the box")
default:
    print("\(somePoint) is outside of the box")
}
// Prints "(1, 1) is inside the box"
```

- switchì˜ value binding(ì¼€ì´ìŠ¤ì— ì¼ì¹˜í•˜ëŠ” ê°’ë“¤ì„ ì„ì‹œ ìƒìˆ˜/ë³€ìˆ˜ë¡œ ë§Œë“¤ì–´ ì‚¬ìš© ê°€ëŠ¥)
- ì•„ë˜ë¥¼ ë³´ë‹ˆê¹Œ "íŒ¨í„´ì´ ì¼ì¹˜í• ë•Œ"ë¼ëŠ” ë§ì´ ë¬´ìŠ¨ ë§ì¸ì§€ ë” ì™€ë‹¿ëŠ”ë‹¤.

ë§Œì•½ anotherPointì˜ ê°’ì´ (2, 100)ì´ì—ˆë‹¤ë©´ 3ë²ˆì§¸ ì¼€ì´ìŠ¤ê°€ ì‹¤í–‰ë¨. ì™œëƒí•˜ë©´ ì²«ë²ˆì§¸, ë‘ë²ˆì§¸ ì¼€ì´ìŠ¤ì˜ íŒ¨í„´ì´ anotherPointì˜ íŒ¨í„´ê³¼ ì¼ì¹˜í•˜ì§€ ì•Šê¸° ë•Œë¬¸.

```swift
let anotherPoint = (2, 0)
switch anotherPoint {
case (let x, 0):
    print("on the x-axis with an x value of \(x)")
case (0, let y):
    print("on the y-axis with a y value of \(y)")
case let (x, y):
    print("somewhere else at (\(x), \(y))")
}
// Prints "on the x-axis with an x value of 2"

```

- case ì¡°ê±´ì´ ëª¨ë“  ìƒí™©ì„ ë°›ì•„ë“¤ì´ê¸°ì— ì ì ˆí•˜ë‹¤ë©´ default êµ¬ë¬¸ì„ êµ³ì´ ë„£ì„ í•„ìš”ëŠ” ì—†ë‹¤.

ìœ„ ì½”ë“œë¥¼ ë³´ë©´ default ì¼€ì´ìŠ¤ëŠ” ì—†ì§€ë§Œ `case let (x, y)`ë¥¼ í†µí•´ ì²«ë²ˆì§¸,ë‘ë²ˆì§¸ ì¡°ê±´ì— í•´ë‹¹í•˜ì§€ ì•ŠëŠ” ê°’ì„ ì²˜ë¦¬í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— defaultë¥¼ ë„£ì§€ ì•Šì€ ê±¸ ë³¼ ìˆ˜ ìˆìŒ.

- switchëŠ” whereë¥¼ ì´ìš©í•´ ì¶”ê°€ì¡°ê±´ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

```swift
let anotherPoint = (91, 0)
switch anotherPoint {
case (let x, 0) where x > 90:
    print("y is 0, x is \(x) which bigger than 90")
case (0, let y) where y < 100:
    print("x is 0, y is \(y) which smaller than 100")
case let (x, y) where x == y:
    print("x(\(x)) and y(\(y)) are equal.")
case let (x, y):
    print("somewhere else at (\(x), \(y))")
}
// Prints "y is 0, x is 91 which bigger than 90"
```

- caseì— ì—¬ëŸ¬ê°œì˜ ì¡°ê±´ì„ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤. ì´ë•Œ , ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì¡°ê±´ì„ ë‚˜ëˆˆë‹¤. ì´ë¥¼ compound caseë¼ê³  ë¶€ë¥¸ë‹¤.
- compound caseëŠ” ê°’ ë°”ì¸ë”© ì—­ì‹œ ê°€ëŠ¥í•˜ë‹¤. ë‹¨, comound caseì˜ **ë°”ì¸ë”©í•  ì„ì‹œë³€ìˆ˜ë‚˜ ìƒìˆ˜ì˜ ì´ë¦„ê³¼ íƒ€ì…ì€ ë™ì¼**í•´ì•¼í•œë‹¤.

**ğŸ¤”Â  ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´**

ì™€ì¼ë“œì¹´ë“œ íŒ¨í„´ì€ _ë¡œ í‘œí˜„ë˜ë©°, ê°’ì„ ë¬´ì‹œí•˜ëŠ” íŒ¨í„´ì´ë‹¤. ì´ì™¸ì—ë„ Swiftì—ì„œëŠ” ë‹¤ì–‘í•œ ì¢…ë¥˜ì˜ íŒ¨í„´ì„ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ”ë° ì´ëŠ” [Swift Programming Guide - Patterns](https://bbiguduk.gitbook.io/swift/language-reference/patterns)ì—ì„œ ë³¼ ìˆ˜ ìˆìŒ.

# ì œì–´ ë³€ê²½í•˜ê¸°

- ì½”ë“œê°€ ì‹¤í–‰ë˜ëŠ” ìˆœì„œë¥¼ ë³€ê²½í•¨
- í‚¤ì›Œë“œ - continue, break, fallthrough, return(í•¨ìˆ˜ì— ë‚˜ì˜´), throw(ì—ëŸ¬ í•¸ë“¤ë§ì— ë‚˜ì˜´)
- continue : ë£¨í”„ì•ˆì—ì„œ ì‚¬ìš©ë˜ë©° ë£¨í”„ë¥¼ ë²—ì–´ë‚˜ì§€ ì•Šê³ ë„ ì´ ë£¨í”„ëŠ” ì¢…ë£Œë˜ì—ˆìœ¼ë‹ˆ ë‹¤ìŒ ë£¨í”„ë¥¼ ì‹¤í–‰í•˜ë¼ëŠ” ê²ƒì„ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆìŒ.
- break : ë£¨í”„ë¥¼ ê·¸ ì¦‰ì‹œ ì¢…ë£Œí•œë‹¤. breakê°€ ì‹¤í–‰ë˜ë©´ ë£¨í”„ì˜ ë‹«ê¸° ì¤‘ê´„í˜¸(`}`) ë‹¤ìŒë¶€í„° ì½”ë“œ ì‹¤í–‰ë¨. ë£¨í”„ ì•ˆì— ìˆëŠ” ifì—ì„œ breakë¥¼ í˜¸ì¶œí•˜ë©´ ifì˜ ë‹«ê¸° ì¤‘ê´„í˜¸ê°€ ì•„ë‹ˆë¼ ë£¨í”„ì˜ ë‹«ê¸° ì¤‘ê´„í˜¸ ë‹¤ìŒë¶€í„° ì½”ë“œ ì‹¤í–‰ë¨.
- fallthrough : switchë¬¸ì—ì„œ ì‚¬ìš©ë˜ë©° ì¼ì¹˜í•˜ëŠ” ì²«ë²ˆì§¸ ì¼€ì´ìŠ¤ì˜ êµ¬ë¬¸ì„ ì‹¤í–‰í•œ í›„ ë‹¤ìŒìœ¼ë¡œ ì¼ì¹˜í•˜ëŠ” ì¼€ì´ìŠ¤ì˜ êµ¬ë¬¸ë„ ì‹¤í–‰ì‹œí‚¤ê¸° ìœ„í•´ ì‚¬ìš©ë¨.
    
    â—ï¸ fallthrough í‚¤ì›Œë“œëŠ” ë‹¤ìŒ ì¼€ì´ìŠ¤ë¡œ ë„˜ì–´ê°ˆ ë•Œ ì¡°ê±´ì„ í™•ì¸í•˜ì§€ ì•ŠëŠ”ë‹¤.
    

# ë¼ë²¨ì´ ìˆëŠ” êµ¬ë¬¸(Labeled Statements)

- ë³µì¡í•œ ì œì–´êµ¬ë¬¸ì„ ë§Œë“¤ê¸° ìœ„í•´ ì¡°ê±´ë¬¸/ë°˜ë³µë¬¸ ì•ˆì— ë‹¤ë¥¸ ì¡°ê±´ë¬¸/ë°˜ë³µë¬¸ì„ ë„£ì„ ìˆ˜ ìˆìŒ.(ì¤‘ì²© ê°€ëŠ¥í•˜ë‹¤)

- ì¤‘ì²©ëœ ë°˜ë³µë¬¸/ì¡°ê±´ë¬¸ì—ì„œ ë°”ê¹¥ìª½ì— ìˆëŠ” ë°˜ë³µë¬¸/ì¡°ê±´ë¬¸ì„ ì»¨íŠ¸ë¡¤í•˜ë ¤ê³  í•  ë•Œ ë¼ë²¨ì´ ìˆìœ¼ë©´ ìœ ìš©í•˜ë‹¤.

- ë¼ë²¨ì„ ë¶™ì¼ ë•Œì—ëŠ” ë£¨í”„, if í‚¤ì›Œë“œ ì•ì— `ë¼ë²¨ì´ë¦„ :`  ì„ ë¶™ì¸ë‹¤. 

# ì´ë¥¸ ì¢…ë£Œ (Early Exit)

- guard êµ¬ë¬¸ì„

- ì¡°ê±´ì´ ëª¨ë‘ ì°¸ì¼ ë•Œ ë‹¤ìŒì„ ì‹¤í–‰í•¨. guardëŠ” í•­ìƒ elseê°€ ê°™ì´ ì™€ì•¼í•¨(ì¡°ê±´ì´ falseì¼ ë•Œ ì‹¤í–‰í• )

- elseì—ëŠ” guardêµ¬ë¬¸ì´ ì¡´ì¬í•˜ëŠ” ì½”ë“œë¸”ëŸ­ì„ ì¢…ë£Œí•˜ê¸° ìœ„í•´ ì œì–´ë¥¼ ì´ë™ì‹œì¼œì•¼ í•œë‹¤.

   ë”°ë¼ì„œ return, break, continue, throw, fatalError(_:file:line:) ê³¼ ê°™ì´ ë˜ëŒì•„ê°€ì§€ ì•ŠëŠ” í•¨ìˆ˜ ë˜ëŠ” ë©”ì„œë“œë¥¼ ì‚¬ìš©í•´ì•¼í•¨.

# Sequence Protocol

- Sequence : í•œë²ˆì— í•˜ë‚˜ì”© ì§„í–‰ë˜ëŠ” ê°’ì˜ ë¦¬ìŠ¤íŠ¸

- ìš”ì†Œë“¤ì— ëŒ€í•œ ìˆœì°¨ì ì´ê³  ë°˜ë³µì ì¸ ì ‘ê·¼ì„ ì œê³µí•˜ëŠ” íƒ€ì…ì…ë‹ˆë‹¤. 

   Sequence protocolì„ ì±„íƒí•˜ë©´ for-inë£¨í”„ë‚˜ contains, map, filter, reduce, lazy, foreach, enumerated, sorted ë“±ê³¼ ê°™ì€ ë‹¤ì–‘í•œ ë©”ì†Œë“œë“¤ì„ ì œê³µí•©ë‹ˆë‹¤.

- Sequenceì˜ íŠ¹ì§•ì€ í¬ê²Œ ë‘ê°€ì§€ë¡œ ë‹¤ìŒê³¼ ê°™ì€ë°ìš”.

   â‘ ìœ í•œí•˜ê±°ë‚˜ ë¬´í•œí•˜ë‹¤ â‘¡ ë”± í•œë²ˆë§Œ iterateí•  ìˆ˜ ìˆë‹¤ 

ğŸ¤”Â  ì—¬ê¸°ì„œ íŠ¹ì´í•œ ê±´ ë”± í•œë²ˆë§Œ iterateí•  ìˆ˜ ìˆë‹¤ëŠ” ë‚´ìš©ì…ë‹ˆë‹¤. ì™œ ê·¸ëŸ´ê¹Œìš”?

*â€” ì¶œì²˜ ğŸ‘€Â : [[Apple Document] Swift - Sequence](https://developer.apple.com/documentation/swift/sequence)*

Sequence í”„ë¡œí† ì½œì€ iterationì— ì˜í•´ ìš”ì†Œë“¤ì´ íŒŒê´´ì ìœ¼ë¡œ ì†Œë¹„ë˜ëŠ” ê²ƒê³¼ ê´€ë ¨í•´, Sequence í”„ë¡œí† ì½œì„ ì±„íƒí•œ íƒ€ì…ì—ê²Œ ì–´ë– í•œ ìš”êµ¬ë„ í•˜ì§€ ì•ŠëŠ”ë‹¤. ë”°ë¼ì„œ sequenceì— ëŒ€í•œ ì—¬ëŸ¬ë²ˆì˜ for-in ë£¨í”„ë¥¼ ì‹¤í–‰í•˜ëŠ” ê²ƒì´ ë°˜ë³µì„ ì¬ê°œí•˜ê±°ë‚˜ ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‹œì‘í•  ê²ƒì´ë¼ê³  ê°€ì •í•˜ì§€ ë§ˆë¼.

collectionì´ ì•„ë‹Œ sequenceëŠ” ë‘ë²ˆì§¸ for-in loopì—ì„œ ì„ì˜ì˜ ì‹œí€€ìŠ¤ë¥¼ ìƒì„±í•  ìˆ˜ ìˆë‹¤? 

ì»¤ìŠ¤í…€í•˜ëŠ” íƒ€ì…ì´ nondestructive iterationì„ ì§€ì›í•˜ê²Œ ë§Œë“¤ê³  ì‹¶ë‹¤ë©´, Collection protocolì„ ì±„íƒí•´ë¼.

- Sequence protocolì„ ì±„íƒí•˜ê¸° ìœ„í•´ì„œëŠ” `makeIterator()` ë©”ì†Œë“œë¥¼ êµ¬í˜„í•˜ë©´ ëœë‹¤.