## Clean Architecture
로버트 C. 마틴

---
### 1장. 설계와 아키텍처
- 소프트웨어 : 기계의 행위를 쉽게 변경할 수 있도록 하기 위해 만들어짐. 따라서 이해관계자가 기능에 대한 생각을 바꾸면 이런 변경사항을 간단하고 쉽게 적용할 수 있어야 한다.  
### 3장. 패러다임 개요
- 패러다임 = 어떤 것을 보고 이해하는 시각, 관점
- 프로그래밍 패러다임은 무엇을 해야할지를 말하기보다는 **무엇을 해서는 안되는지**를 말해준다.  
### 4장. 구조적 프로그래밍(Structured Programming)
- 여기서 "구조적"은 실행흐름을 제어하는 제어 구조를 말한다. 
- '**프로그램을 만들 때 순차, 분기, 반복만으로 프로그램을 짜는 패러다임**' 이라고 이해함.
- 근데 여기서 의문이 들 수 있다. 순차, 분기, 반복 이외의 방법으로 개발을 할 수 있다고??? 이건 그냥 너무 당연한거 아니야???
- 옛날 옛적에...
    - 1968년 데이크스트라가 **발견**
    - 왜 나오게 되었나?
        - 데이크스트라가 해결하고자 했던 문제와 문제점, 해결방안은 아래와 같다.
            * 문제  
            프로그래밍은 어렵고, 프로그래머는 프로그래밍을 잘 하지 못한다.
            * 문제점(문제의 원인)  
            모든 프로그래밍은 인간의 두뇌로 감당하기에는 너무 많은 세부사항이 담겨있다.  
            그래서 조금이라도 세부사항이 누락되면 잘 동작하는 것처럼 보여도 예상 외의 오류가 발생할 수 있다.
            * 해결방안  
            너무 크니까 이를 쪼개고 쪼개서 작은 단위로 잘 동작하는지를 입증하고 이렇게 입증된 것들을 결합시켜 코드가 올바르다는 사실을 스스로 증명하도록 만들자!
        - 해결방안을 실행에 옮기기 위해서는 코드를 입증 가능한 아주 작은 단위로(필요하다면 재귀적으로) 쪼개야 했다. 
        - 하지만 문제가 있었다. **실행흐름을 프로그래머 마음대로 컨트롤할 수 있는 `goto`문**으로 인해 쪼개기가 어려웠던 것이다. 
        - `goto`문을 사용하더라도 쪼개는데 방해가 되지 않는 경우도 있었는데 순차,분기,반복의 조합인 경우였다. 
        - 순차, 분기, 반복만으로 프로그램을 만들면 입증 가능한 최소단위를 만들 수 있고 그럼 이를 결합시켜 제대로 동작하는 프로그램을 만들 수 있다.
    - 1968년, 데이크스트라는 'goto문의 해로움'이라는 내용을 공식 발표했다. 
    - 당시 많은 논란이 있었지만 모던 언어들이 `goto`을 지원하지 않으면서 이러한 사고방식은 많은 사람들에게 받아들여졌다.
> 즉, 그때 그 시절에는 goto를 이용해 마음대로 실행 흐름을 조절할 수 있었다.😲  
~~아마 회사 내부적으로 비즈니스 환경에 맞게 커스텀된 실행흐름도 있지 않았을까한다. 아주 다양한 실행흐름 패턴이 있었는데~~ 
구조적 프로그래밍이 발표되면서 실행흐름을 "순차, 분기, 반복"으로 제한한 것이다.

> 데이크스트라의 발표는 1968년이 나왔다.  
하지만 이에 대한 필요성은 이미 그 전부터 많은 공감대를 얻지 않았을까 하는 생각이 든다.   
    ✓ 데이크스트라의 발견 2년 전에 이미 두 명의 프로그래머가 순차/분기/반복만으로도 프로그램을 만들 수 있다는 것을 증명했다.  
    ✓ [1958년에 나온 LISP 언어](https://ko.wikipedia.org/wiki/%EB%A6%AC%EC%8A%A4%ED%94%84)는 처음부터 goto문이 없었다고 한다.

* 테스트와 과학적 증명
    * 테스트는 버그가 있음을 보여줄 뿐 버그가 없음을 보여줄 수는 없다.
    * 과학적 증명은 서술된 내용이 틀렸음을 증명하는 방식으로 동작한다. 이런 동작 원리는 프로그래밍에도 적용되는데 테스트를 모두 통과하면 완전 무결하게 "옳다"고 말할 수는 없지만 **프로그램이 목표에 부합할 만큼 옳다**라고 볼 수는 있다.

### 5장. 객체지향 프로그래밍
OO의 다양한 정의

- 데이터와 함수의 조합 → o.f()와 f(o)가 서로 다르다는 의미를 내포하고 있다. 객체의 특정 함수를 호출하면 내부적으로 그 객체의 데이터들을 활용하는거임. 함수의 매개변수로 객체를 전달하면 함수 내에서 그 객체의 데이터를 사용함. 이게 진짜 서로 다른 기능인걸까? 기능적으로 보면 서로 동일한 거임. 그리고 OO가 나오기 이전부터 많은 개발자들은 f(o)를 사용하고 있었다.
    
- 실제세계를 모델링하는 방법이다.
- 캡슐화, 상속, 다형성
    - 캡슐화 : OO가 진짜 캡슐화(외부에서 내부 데이터에 접근할 수 없고 볼 수 없는 것)를 잘 지원하는가? C++의 경우 기술적인 이유로 인해 헤더파일에 멤버변수를 선언하는데 접근은 불가능해도 이용하는쪽에서 어떤 멤버변수가 있는지 볼 수는 있다.
    - 상속 : OO언어가 나오기 이전부터도 (편리한 방법은 아니었지만) 상속을 지원하긴 했다.
    - 다형성 : 공통적으로 사용될 함수를 정의 → 특정 strcut에서 공통 기능의 구체적인 구현을 정의 → 사용하는 쪽에서는 공통 기능을 호출하기만 하면 됨. 이런 방식으로 다형성을 구현했다. **함수를 가리키는 포인터를 응용**한 것이 다형성이다.  
    - 포인터를 직접 제어하는 것은 예상치 못한 버그를 만듬. OO는 포인터 제어를 좀 더 안전한 방식으로 할 수 있도록 함.(규칙을 강제)
        
- 의존성 역전
    - 소스코드 의존성 : A라는 코드를 실행하는데 반드시 B라는 파일이 코드상 필요하다면 A는 B에 의존하고 있다고 말할 수 있다. 코드를 단독으로 실행시킬 수 없고 반드시 다른 무언가를 의존해야 하는 것. 그래서 의존하고 있는 파일이 변경됐을 때 변경이 반드시 수반되는 것.
    - 49페이지 그림 5.2 : HL1이 코드 상으로 인터페이스의 함수를 호출. ML1에서는 코드 상 인터페이스의 함수를 호출하는 것. 코드적으로 인터페이스만 의존한다.
- OO가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이다. ( 소스코드 의존성 역전은 제어흐름과 반대로 의존성 방향을 만들 수 있음을 의미한다.)
- OO란 다형성을 이용하여 전체 시스템의 모든 **소스코드 의존성**에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
- OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있다.
- 플러그인 아키텍처? : [https://luckygg.tistory.com/265](https://luckygg.tistory.com/265)

### 6장. 함수형 프로그래밍
- 함수형 프로그래밍 : 순수함수와 변하지 않는 변수로 프로그램을 만드는 것.
    
    함수형 프로그래밍을 이용하면 (변하지 않는 변수 덕분에) 경합 조건, 교착상태 조건, 동시 업데이트 문제 등을 방지할 수 있다.
    
- [경합 조건](https://velog.io/@sinclebear/12%EC%9E%A5.-%EA%B2%BD%ED%95%A9-%EC%A1%B0%EA%B1%B4%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-%EA%B3%B5%EC%9C%A0-%EC%9E%90%EC%9B%90)
    - 두개 또는 그 이상의 프로그램이 공유 자원에 동시 접근.
    - 접근을 처리하는 순서에 따라 결과가 달라짐. 그냥 읽는 작업이라면 순서가 달라도 결과가 달라지진 않을 것이다. 하지만 업데이트(수정,삭제)가 발생하기 때문에 이런 문제가 발생하는 것.
- [교착 상태(deadlock)](https://ko.wikipedia.org/wiki/%EA%B5%90%EC%B0%A9_%EC%83%81%ED%83%9C) 조건
    - [lock에는 두가지 종류가 있다.](https://velog.io/@yrkim/Database-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-deadlock) read lock과 write lock. read lock은 여러 곳에서 읽을 수는 있지만 변경은 불가하도록 막는 것이다. write lock은 데이터를 변경할 때 사용되며 이 lock이 걸려있는 동안 다른 곳에서 읽거나 쓸 수 없다.
    - deadlock은 read lock과 write lock 또는 write lock과 write lock 사이에 발생함. lock이 가변적이기 때문에 발생한다?
    - 두개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못함.
    - ex. 사다리에 두 사람이 있음. 한 사람은 내려가려하고 한 사람은 올라가려 함. 서로 비켜줄 때까지 계속 기다려야하는 것.
- 동시 업데이트 : 두개 또는 그 이상의 프로그램이 동일한 특정 자원을 동시에 업데이트하는 것. ( 데이터를 가공하는 작업이 필요하지 않으면 애초에 업데이트 작업도 일어나지 않음으로 동시 업데이트 문제 발생 X )

- 이벤트 소싱 : 트랜잭션을 저장하고 상태가 필요할 경우 이 트랜잭션으로부터 실시간으로 추출하자! 이런 느낌인듯. 소스코드 버전 관리 시스템이 이 방식으로 동작한다.
## SOLID 원칙
### SRP(Single Responsibility Principle) : 단일 책임 원칙
- 함수는 딱 하나의 일만 한다.가 아님. 하나의 모듈은 단 하나의 액터를 책임져야 한다. 
- 무작정 코드의 중복을 피하기 위해 함수를 합치거나 한 적이 많음. 보통 Util이라는 이름을 가진 것들에 공통되는 기능들을 넣어뒀지. 이렇게 코드를 만들어도 되나 하는 고민이 많았었는데 SRP는 그 기준을 제시하는 것 같다. 즉, 그 기능을 사용하고 영향을 줄 수 있는 이해관계 집단이 딱 하나여야 한다는 것. 그래야 다른 곳에 영향을 미칠 가능성이 줄어들고 유연하게 변화에 대응할 수 있다.

### OCP(Open-Closed Principle) : 개방-폐쇄 원칙
- 확장에 열려있어야 하고 변경에는 닫혀 있어야(=변경이 필요치 않도록)한다.
- 변경에 닫혀있도록 만들기 위해서는 소스코드 의존성을 줄여나가야 한다.

### LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
- 여기서 `치환`이란 상위타입을 하위타입으로 치환하는 것을 의미한다.
- 하위타입에 대한 리스코프의 정의는 다음과 같다.
    > 여기에서 필요한 것은 다음과 같은 치환(substitution)원칙이다. S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위타입이다.
- 간단히 말해 **소스코드 상에서 상위 타입을 하위 타입으로 치환하더라도 완벽하게 동작해야한다**가 리스코프 치환 원칙이다. 
- 근데 의아할 수 있다. 하위 타입으로 치환했을 때 문제가 생기는 경우가 있나? 당연히 치환 되야하는거 아님?!
    ```Swift
    enum Drink {
        case water
        case milk
        case greenTea
    }

    protocol Cup {
        func fill(drink: Drink)
        func putInMicrowave()
        func heat(min: Int)
        func pull()
    }

    struct GlassCup: Cup {
        func fill(drink: Drink) { }
        func putInMicrowave() { }
        func heat(min: Int) { }
        func pull() { }
    }

    struct PlasticCup: Cup {
        func fill(drink: Drink) { }
        func putInMicrowave() { }
        func heat(min: Int) { }
        func pull() { }
    }

    let cup = Cup()
    cup.fill()
    cup.putInMicrowave()
    cup.heat(min: 2)
    cup.pull()
    
    ```
    위 예제 코드에서 Cup을 GlassCup으로 치환하면 정상적으로 동작할 것이다. 유리컵은 전자레인지에 돌려도 안에 있는 음료와 함께 따뜻해질뿐이니까.   
    그렇지만 PlasticCup으로 치환하면 정상적으로 동작하지 않는다. 플라스틱 컵은 전자레인지에 돌렸을 때 녹거든!   
    이런 케이스가 상위타입을 하위타입으로 치환했을 때 문제가 생기는 경우다.(이해를 돕기위한 예시임!! LSP를 위반한 형태가 구체적으로 저런 형태다? ㄴㄴ)
- 리스코프 치환원칙은 단순히 "상위 타입을 하위타입으로 치환할 수 있어야 한다"로 끝나는 것이 아니다. **사전에 약속한 기획대로 구현해야 하기 때문에 하위 타입을 생성할 때 상위 타입에서 구현한 원칙을 따라야 한다**가 핵심이다.
- 이어지는 내용들은 모두 [여기](https://pizzasheepsdev.tistory.com/9)를 참고한 것이다. 리스코프 치환원칙을 이해하는데 많은 도움이 됐다.
- 하위타입이 만족해야 하는 행동 조건들이 있다.
    - **하위 타입에서 선행 조건은 강화될 수 없다.**   
    선행 조건은 사전 조건이라고도 하는데 사전적 의미로 함수가 오류없이 실행되기 위한 모든 조건을 정의한 것이다.
        ```Swift
        enum someError: Error {
            case negative
            case zero
        }
        func someMethod(number: Int) throws {
            if number < 0 {
                throw someError.negative
            }
        }
        ```
        위 코드에서 매개변수로 들어온 값이 의도한대로 올바르게 들어왔는지 체크하는 것을 선행 조건이라고 한다.   
        `선행 조건이 강화됐다.` 라는 것은 선행 조건을 추가하는 걸 말하는데 리스코프 원칙은 이렇게 코드를 짜서는 안된다는 것을 말한다.   
        왜냐하면 상위 타입과 동일한 수준의 선행조건을 기대하고 코드를 사용하기 때문임.
        ```Swift
        // 위 코드의 someError enum 그대로 사용

        func someMethod(number: Int) throws {
            if number < 0 {
                throw someError.negative
            }
            if number == 0 {
                throw someError.zero
            }
        }
        ```
    - **하위 타입에서 후행 조건은 약화될 수 없다.**   
    후행 조건은 사후 조건이라고도 하는데 사전적 의미로 함수 호출 후 객체가 유효한 상태로 존재하는지를 검사하는 것이다.
        ```Swift
        func subtract(number: Int) {
            var result = number

            for i in 0...3 {
                result -= 5
            }

            // 아래 코드가 후행 조건에 해당된다. 함수 처리 후 리턴값이나 매개변수로 전달된 참조형 값이 제대로 된 값인지 검사하는 것.
            if result < 0 {
                result == 0
            }

            return result
        }
        ```
        후행 조건이 약화된다는 것은 값을 리턴할 때 조건을 완화시킨다는 것이다. 즉, 위 코드에서 `result < 0`을 검사하지 않고 리턴하는거임. 이렇게 짜면 안된다!
    - **하위 타입에서 상위타입의 불변조건은 반드시 유지되야 한다.**   
        ```Swift
        fileprivate protocol SomeProtocol {
            var num: Int { get set }
        }
        class Parent: SomeProtocol {
            fileprivate var num: Int = 10
            var number: Int {
                get { 
                    return num
                }
                set {
                    if newValue < 0 {
                        num = 0
                    }
                }
            }
        }
        ```
        위의 Parent 클래스의 `number`는 계산 프로퍼티로 private인 `num`의 getter/setter 역할을 한다.   
        만약 `number`에 음수가 들어올 경우 이를 체크해서 `num`에는 항상 0 혹은 양수가 들어가도록 처리되어 있다.
        ```Swift
        class Child: Parent {
            override var number: Int {
                get { 
                    return num
                }
                set {
                    num = newValue
                }
            }
        }
        ```
        하지만 Child 클래스에서 `number` 계산 프로퍼티의 음수 체크 조건을 제거하고 오버라이딩할 경우 `num`에는 항상 0 혹은 양수가 들어가야 한다는 상위 타입의 조건이 깨지는 문제가 발생한다.(음수 넣으면 음수도 할당됨)   
        이런 경우가 불변 조건이 깨지는 경우이며 LSP가 깨지는 경우이다.

- 하위타입이 지켜야하는 메소드 시그니처 조건들도 있다.
    - 하위타입 메소드는 상위타입 메소드에서 던져진 예외의 하위타입을 제외하고 새로운 예외를 던지면 안된다.   
    왜냐면 상위타입을 하위타입으로 치환했을 때 예상치 못한 에러를 던질 경우 받는 쪽에서 적절한 처리를 할 수 없기 때문이다.
    - 공변성과 반공변성
        변성 : Child가 Parent의 서브타입일때 Child의 컬렉션타입과 Parent의 컬렉션 타입 간 관계 변화를 의미한다.

- 👀 더 봐야할 것(출처 : [이 글](https://pizzasheepsdev.tistory.com/9))
    - 리스코프의 원칙은 새로운 객체 지향 프로그래밍 언어에 채용된 시그니처에 관한 몇 가지 표준적인 요구사항을 강제한다.
        - 하위형에서 메서드 인수의 반공변성 
        - 하위형에서 반환형의 공변성
        - 하위형에서 메서드는 상위형 메서드에서 던져진 예외의 하위형을 제외하고 새로운 예외를 던지면 안 된다.

### ISP(Interface Segregation Principle)
- *[no code should be forced to depend on methods it does not use.](https://en.wikipedia.org/wiki/Interface_segregation_principle)*   
어떠한 코드도 사용하지 않는 메소드에 강제로 의존해서는 안된다.
- 큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로서 클라이언트가 필요한 메소드만 사용하도록 만들어야 한다.
- 예제 코드를 보자! 출처는 [여기](https://pizzasheepsdev.tistory.com/10?category=849060)
    ```Swift
    protocol DataManagable {
        associatedtype
        func load()
        func prepare()
        func save()
    }

    struct DataLoader: DataManagable {
        func load() {  }
        func prepare() {  }
        func save() {  }
    }

    ```
    위의 코드에서 `DataLoader` 구조체는 실질적으로 load() 메소드만 필요하다. 나머지 메소드는 불필요한 상태임.   
    근데 요구사항이 변경되서 save() 메소드의 시그니처가 변경되어 `Bool`을 리턴해야하는 상황이라면 사용도 하지않는 save() 메소드로 인해 `DataLoader` 구조체의 수정이 불가피하다.   
    이런 상황을 방지하기 위한 것이 ISP임.


### DIP(Dependency Inversion Principle)
- 의존성 역전이란 소스 코드의 의존성이 제어흐름과는 반대방향으로 역전되는 것을 말하며 이는 추상 인터페이스를 구현하고 이를 통해 동작하도록 만듦으로서 이루어진다.
- 따라서 소스코드 의존성이 항상 추상에 의존해야한다. 하지만 이는 현실적으로 어렵다.
- 그렇기 때문에 안정적이라 추후 변화가 없는 경우, 변경이 있더라도 엄격하게 통제되는 경우라면 구체(concretion)에 의존해도 괜찮다.
- *구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말아라.*
- 👀 더 봐야할 것
    - 추상 팩토리란?
    - 의존성 주입이란?