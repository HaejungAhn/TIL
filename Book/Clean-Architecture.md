## Clean Architecture
로버트 C. 마틴

---
- 소프트웨어 : 기계의 행위를 쉽게 변경할 수 있도록 하기 위해 만들어짐. 따라서 이해관계자가 기능에 대한 생각을 바꾸면 이런 변경사항을 간단하고 쉽게 적용할 수 있어야 한다.  
- 패러다임 = 어떤 것을 보고 이해하는 시각, 관점
- 프로그래밍 패러다임은 무엇을 해야할지를 말하기보다는 **무엇을 해서는 안되는지**를 말해준다.  
### 구조적 프로그래밍(Structured Programming)
- 여기서 "구조적"은 실행흐름을 제어하는 제어 구조를 말한다. 
- '**프로그램을 만들 때 순차, 분기, 반복만으로 프로그램을 짜는 패러다임**' 이라고 이해함.
- 근데 여기서 의문이 들 수 있다. 순차, 분기, 반복 이외의 방법으로 개발을 할 수 있다고??? 이건 그냥 너무 당연한거 아니야???
- 옛날 옛적에...
    - 1968년 데이크스트라가 **발견**
    - 왜 나오게 되었나?
        - 데이크스트라가 해결하고자 했던 문제와 문제점, 해결방안은 아래와 같다.
            * 문제  
            프로그래밍은 어렵고, 프로그래머는 프로그래밍을 잘 하지 못한다.
            * 문제점(문제의 원인)  
            모든 프로그래밍은 인간의 두뇌로 감당하기에는 너무 많은 세부사항이 담겨있다.  
            그래서 조금이라도 세부사항이 누락되면 잘 동작하는 것처럼 보여도 예상 외의 오류가 발생할 수 있다.
            * 해결방안  
            너무 크니까 이를 쪼개고 쪼개서 작은 단위로 잘 동작하는지를 입증하고 이렇게 입증된 것들을 결합시켜 코드가 올바르다는 사실을 스스로 증명하도록 만들자!
        - 해결방안을 실행에 옮기기 위해서는 코드를 입증 가능한 아주 작은 단위로(필요하다면 재귀적으로) 쪼개야 했다. 
        - 하지만 문제가 있었다. **실행흐름을 프로그래머 마음대로 컨트롤할 수 있는 `goto`문**으로 인해 쪼개기가 어려웠던 것이다. 
        - `goto`문을 사용하더라도 쪼개는데 방해가 되지 않는 경우도 있었는데 순차,분기,반복의 조합인 경우였다. 
        - 순차, 분기, 반복만으로 프로그램을 만들면 입증 가능한 최소단위를 만들 수 있고 그럼 이를 결합시켜 제대로 동작하는 프로그램을 만들 수 있다.
    - 1968년, 데이크스트라는 'goto문의 해로움'이라는 내용을 공식 발표했다. 
    - 당시 많은 논란이 있었지만 모던 언어들이 `goto`을 지원하지 않으면서 이러한 사고방식은 많은 사람들에게 받아들여졌다.
> 즉, 그때 그 시절에는 goto를 이용해 마음대로 실행 흐름을 조절할 수 있었다.😲  
~~아마 회사 내부적으로 비즈니스 환경에 맞게 커스텀된 실행흐름도 있지 않았을까한다. 아주 다양한 실행흐름 패턴이 있었는데~~ 
구조적 프로그래밍이 발표되면서 실행흐름을 "순차, 분기, 반복"으로 제한한 것이다.

> 데이크스트라의 발표는 1968년이 나왔다.  
하지만 이에 대한 필요성은 이미 그 전부터 많은 공감대를 얻지 않았을까 하는 생각이 든다.   
    ✓ 데이크스트라의 발견 2년 전에 이미 두 명의 프로그래머가 순차/분기/반복만으로도 프로그램을 만들 수 있다는 것을 증명했다.  
    ✓ [1958년에 나온 LISP 언어](https://ko.wikipedia.org/wiki/%EB%A6%AC%EC%8A%A4%ED%94%84)는 처음부터 goto문이 없었다고 한다.

* 테스트와 과학적 증명
    * 테스트는 버그가 있음을 보여줄 뿐 버그가 없음을 보여줄 수는 없다.
    * 과학적 증명은 서술된 내용이 틀렸음을 증명하는 방식으로 동작한다. 이런 동작 원리는 프로그래밍에도 적용되는데 테스트를 모두 통과하면 완전 무결하게 "옳다"고 말할 수는 없지만 **프로그램이 목표에 부합할 만큼 옳다**라고 볼 수는 있다.

### 객체지향 프로그래밍
OO의 다양한 정의

- 데이터와 함수의 조합 → o.f()와 f(o)가 서로 다르다는 의미를 내포하고 있다. 객체의 특정 함수를 호출하면 내부적으로 그 객체의 데이터들을 활용하는거임. 함수의 매개변수로 객체를 전달하면 함수 내에서 그 객체의 데이터를 사용함. 이게 진짜 서로 다른 기능인걸까? 기능적으로 보면 서로 동일한 거임. 그리고 OO가 나오기 이전부터 많은 개발자들은 f(o)를 사용하고 있었다.
    
- 실제세계를 모델링하는 방법이다.
- 캡슐화, 상속, 다형성
    - 캡슐화 : OO가 진짜 캡슐화(외부에서 내부 데이터에 접근할 수 없고 볼 수 없는 것)를 잘 지원하는가? C++의 경우 기술적인 이유로 인해 헤더파일에 멤버변수를 선언하는데 접근은 불가능해도 이용하는쪽에서 어떤 멤버변수가 있는지 볼 수는 있다.
    - 상속 : OO언어가 나오기 이전부터도 (편리한 방법은 아니었지만) 상속을 지원하긴 했다.
    - 다형성 : 공통적으로 사용될 함수를 정의 → 특정 strcut에서 공통 기능의 구체적인 구현을 정의 → 사용하는 쪽에서는 공통 기능을 호출하기만 하면 됨. 이런 방식으로 다형성을 구현했다. **함수를 가리키는 포인터를 응용**한 것이 다형성이다.  
    - 포인터를 직접 제어하는 것은 예상치 못한 버그를 만듬. OO는 포인터 제어를 좀 더 안전한 방식으로 할 수 있도록 함.(규칙을 강제)
        
- 의존성 역전
    - 소스코드 의존성 : A라는 코드를 실행하는데 반드시 B라는 파일이 코드상 필요하다면 A는 B에 의존하고 있다고 말할 수 있다. 코드를 단독으로 실행시킬 수 없고 반드시 다른 무언가를 의존해야 하는 것. 그래서 의존하고 있는 파일이 변경됐을 때 변경이 반드시 수반되는 것.
    - 49페이지 그림 5.2 : HL1이 코드 상으로 인터페이스의 함수를 호출. ML1에서는 코드 상 인터페이스의 함수를 호출하는 것. 코드적으로 인터페이스만 의존한다.
- OO가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이다. ( 소스코드 의존성 역전은 제어흐름과 반대로 의존성 방향을 만들 수 있음을 의미한다.)
- OO란 다형성을 이용하여 전체 시스템의 모든 **소스코드 의존성**에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
- OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있다.
- 플러그인 아키텍처? : [https://luckygg.tistory.com/265](https://luckygg.tistory.com/265)

### 함수형 프로그래밍
- 함수형 프로그래밍 : 순수함수와 변하지 않는 변수로 프로그램을 만드는 것.
    
    함수형 프로그래밍을 이용하면 (변하지 않는 변수 덕분에) 경합 조건, 교착상태 조건, 동시 업데이트 문제 등을 방지할 수 있다.
    
- [경합 조건](https://velog.io/@sinclebear/12%EC%9E%A5.-%EA%B2%BD%ED%95%A9-%EC%A1%B0%EA%B1%B4%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-%EA%B3%B5%EC%9C%A0-%EC%9E%90%EC%9B%90)
    - 두개 또는 그 이상의 프로그램이 공유 자원에 동시 접근.
    - 접근을 처리하는 순서에 따라 결과가 달라짐. 그냥 읽는 작업이라면 순서가 달라도 결과가 달라지진 않을 것이다. 하지만 업데이트(수정,삭제)가 발생하기 때문에 이런 문제가 발생하는 것.
- [교착 상태(deadlock)](https://ko.wikipedia.org/wiki/%EA%B5%90%EC%B0%A9_%EC%83%81%ED%83%9C) 조건
    - [lock에는 두가지 종류가 있다.](https://velog.io/@yrkim/Database-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-deadlock) read lock과 write lock. read lock은 여러 곳에서 읽을 수는 있지만 변경은 불가하도록 막는 것이다. write lock은 데이터를 변경할 때 사용되며 이 lock이 걸려있는 동안 다른 곳에서 읽거나 쓸 수 없다.
    - deadlock은 read lock과 write lock 또는 write lock과 write lock 사이에 발생함. lock이 가변적이기 때문에 발생한다?
    - 두개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못함.
    - ex. 사다리에 두 사람이 있음. 한 사람은 내려가려하고 한 사람은 올라가려 함. 서로 비켜줄 때까지 계속 기다려야하는 것.
- 동시 업데이트 : 두개 또는 그 이상의 프로그램이 동일한 특정 자원을 동시에 업데이트하는 것. ( 데이터를 가공하는 작업이 필요하지 않으면 애초에 업데이트 작업도 일어나지 않음으로 동시 업데이트 문제 발생 X )

- 이벤트 소싱 : 트랜잭션을 저장하고 상태가 필요할 경우 이 트랜잭션으로부터 실시간으로 추출하자! 이런 느낌인듯. 소스코드 버전 관리 시스템이 이 방식으로 동작한다.

### SRP(Single Responsibility Principle) : 단일 책임 원칙
- 함수는 딱 하나의 일만 한다.가 아님. 하나의 모듈은 단 하나의 액터를 책임져야 한다. 
- 무작정 코드의 중복을 피하기 위해 함수를 합치거나 한 적이 많음. 보통 Util이라는 이름을 가진 것들에 공통되는 기능들을 넣어뒀지. 이렇게 코드를 만들어도 되나 하는 고민이 많았었는데 SRP는 그 기준을 제시하는 것 같다. 즉, 그 기능을 사용하고 영향을 줄 수 있는 이해관계 집단이 딱 하나여야 한다는 것. 그래야 다른 곳에 영향을 미칠 가능성이 줄어들고 유연하게 변화에 대응할 수 있다.

### OCP(Open-Closed Principle) : 개방-폐쇄 원칙
- 확장에 열려있어야 하고 변경에는 닫혀 있어야(=변경이 필요치 않도록)한다.
- 변경에 닫혀있도록 만들기 위해서는 소스코드 의존성을 줄여나가야 한다.