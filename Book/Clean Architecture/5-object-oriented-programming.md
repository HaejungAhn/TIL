## 5장. 객체지향 프로그래밍
OO의 다양한 정의

- 데이터와 함수의 조합 → o.f()와 f(o)가 서로 다르다는 의미를 내포하고 있다. 객체의 특정 함수를 호출하면 내부적으로 그 객체의 데이터들을 활용하는거임. 함수의 매개변수로 객체를 전달하면 함수 내에서 그 객체의 데이터를 사용함. 이게 진짜 서로 다른 기능인걸까? 기능적으로 보면 서로 동일한 거임. 그리고 OO가 나오기 이전부터 많은 개발자들은 f(o)를 사용하고 있었다.
    
- 실제세계를 모델링하는 방법이다.
- 캡슐화, 상속, 다형성
    - 캡슐화 : OO가 진짜 캡슐화(외부에서 내부 데이터에 접근할 수 없고 볼 수 없는 것)를 잘 지원하는가? C++의 경우 기술적인 이유로 인해 헤더파일에 멤버변수를 선언하는데 접근은 불가능해도 이용하는쪽에서 어떤 멤버변수가 있는지 볼 수는 있다.
    - 상속 : OO언어가 나오기 이전부터도 (편리한 방법은 아니었지만) 상속을 지원하긴 했다.
    - 다형성 : 공통적으로 사용될 함수를 정의 → 특정 strcut에서 공통 기능의 구체적인 구현을 정의 → 사용하는 쪽에서는 공통 기능을 호출하기만 하면 됨. 이런 방식으로 다형성을 구현했다. **함수를 가리키는 포인터를 응용**한 것이 다형성이다.  
    - 포인터를 직접 제어하는 것은 예상치 못한 버그를 만듬. OO는 포인터 제어를 좀 더 안전한 방식으로 할 수 있도록 함.(규칙을 강제)
        
- 의존성 역전
    - 소스코드 의존성 : A라는 코드를 실행하는데 반드시 B라는 파일이 코드상 필요하다면 A는 B에 의존하고 있다고 말할 수 있다. 코드를 단독으로 실행시킬 수 없고 반드시 다른 무언가를 의존해야 하는 것. 그래서 의존하고 있는 파일이 변경됐을 때 변경이 반드시 수반되는 것.
    - 49페이지 그림 5.2 : HL1이 코드 상으로 인터페이스의 함수를 호출. ML1에서는 코드 상 인터페이스의 함수를 호출하는 것. 코드적으로 인터페이스만 의존한다.
- OO가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이다. ( 소스코드 의존성 역전은 제어흐름과 반대로 의존성 방향을 만들 수 있음을 의미한다.)
- OO란 다형성을 이용하여 전체 시스템의 모든 **소스코드 의존성**에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
- OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있다.
- 플러그인 아키텍처? : [https://luckygg.tistory.com/265](https://luckygg.tistory.com/265)