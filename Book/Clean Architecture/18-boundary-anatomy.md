## 18장. 경계 해부학

이 장에서 알 수 있는 것

- 경계란?
- 경계횡단이란?
- 경계의 여러 형태들

---

### 경계란?
- 시스템 아키텍처는 소프트웨어 컴포넌트와 그 컴포넌트들을 분리하는 경계에 의해 정의된다.
- 17장에서 언급된 경계   
소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하도록 막는다. 즉, 서로가 서로를 인식하지 못하도록 막는다.
- 경계란 변경(소스코드 모듈 변경 혹은 재컴파일 후 새롭게 배포가 필요한 변경)이 전파되는 것을 막는 방화벽을 구축하고 관리하는 수단으로써 존재한다.

### 경계 횡단하기
- "런타임에 경계를 횡단한다"는 말은 그저 한 경계에서 다른 경계에 속한 함수를 호출하여 데이터를 전달하는 일이다.   
- 적절한 위치에서 경계를 횡단하는 비결은 "소스코드 의존성 관리"에 있다.

### 경계의 여러 형태들: 1. 물리적으로 엄격하게 구분되지 않는 형태
- 가장 단순하며 가장 흔한 경계 형태다.
- 함수와 데이터가 단일 프로세서에서 같은 주소 공간을 공유하며 그저 나름의 규칙에 따라 분리되어 있을 뿐이다.   
저자는 이를 소스 수준 분리 모드라고 언급함.
    >소스 수준 분리 모드(16장, 165p)   
    소스 코드 모듈 사이의 의존성을 제어할 수 있음. 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일 하지 않도록 만들 수 있음.
- 이런 아키텍처는 거의 모든 경우에 특정한 동적 다형성에 의존하여 내부 의존성을 관리한다.
- 경계 횡단의 가장 단순한 형태
    - 가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출이다. 이 경우 런타임 의존성과 컴파일타임 의존성은 모두 같은 방향, 즉 저수준 컴포넌트에서 고수준 컴포넌트로 향한다.
    - 고수준 클라이언트가 저수준 서비스를 호출해야 한다면 동적 다형성을 사용하여 제어흐름과는 반대 방향으로 의존성을 역전시킬 수 있다.
- 소스 수준에서 결합이 분리되면 경계를 가로지르는 통신은 상당히 빈번할 수 있다.
- 이런 시스템에서 컴포넌트는 소스코드 형태로 전달된다.



### 경계의 여러 형태들: 2. 동적 링크 라이브러리
- 아키텍처의 경계가 물리적으로 구분되어질 수도 있다. 그 중 가장 단순한 형태가 "동적 링크 라이브러리"다.   
.NET DLL, 자바 jar 파일, 루비 잼, 유닉스 공유 라이브러리 등이 그 예이다.
- 이때 컴포넌트는 배포 가능한 바이너리 형태로 전달되며, 배포 수준 결합분리 모드에 해당된다.
    >배포 수준 분리 모드(16장, 165p)
    배포 가능한 단위들 사이의 의존성을 제어할 수 있음. 한 모듈의 소스코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들 수 있음. 많은 컴포넌트가 여전히 같은 주소 공간에 상주하며 단순한 함수 호출을 통해 통신할 수 있다.
- 모든 함수가 동일한 프로세서와 주소 공간에 위치한다. 컴포넌트 간 의존성을 관리하는 방법도 소스 수준 컴포넌트와 동일하게 다형성을 이용하는데 차이가 있다면 정적 다형성을 사용할 수 없다는 것이다.
- 배포 수준에서 결합이 분리되도 경계를 가로지르는 통신은 그저 함수 호출로 이루어지기 때문에 빈번히 발생할 수 있다.

### 경계의 여러 형태들: 3. 로컬 프로세스
- 2번의 형태보다 훨씬 강한 물리적 형태를 띠는 아키텍처 경계로는 로컬 프로세스가 있다.
- 메모리에 프로그램이 로드될 때 프로세스가 생성되어진다.
- 로컬 프로세스 간 분리 전략은 1번이나 2번에서 사용하는 분리 전략과 동일하다. 저수준 프로세스에서 고수준 프로세스로 의존성 화살표가 향하도록 하는 것이다.
- 로컬 프로세스의 경계를 지나는 통신에는 운영체제 호출, 데이터 마샬링 및 언마샬링, 프로세스 간 문맥교환 등이 있으며 이들은 제법 비싼 작업에 속한다.
- 따라서 너무 빈번하게 이뤄지지 않도록, 신중하게 제한해야 한다.

### 경계의 여러 형태들: 4. 서비스
- 물리적 형태를 띠는 가장 강력한 경계는 서비스다.
- 서비스는 프로세스다.   
    - "로컬 프로세스와는 무슨차이일까?" 아마 "로컬"이라고 언급한 것을 보면 서비스는 서로 다른 컴퓨터에 위치한 프로세스이지 않을까한다.
- 서비스는 자신의 물리적 위치에 구애받지 않는다. 즉, 서로 통신하는 두 서비스는 물리적으로 동일한 프로세서나 멀티코어에서 동작할 수도 있고 아닐수도 있다.
- 서비스들은 **모든 통신이 네트워크를 통해 이루어진다고 가정**한다.
- 서비스의 경계를 지나는 호출은 함수 호출에 비해 매우 느리다. (네트워크를 통해 이루어지기 때문에) 따라서 주의를 기울여야 하며 지연(latency)에 따른 문제를 고수준에서 처리할 수 있어야 한다.
- 고수준 서비스의 소스코드에서 저수준 서비스를 특정짓는 어떤 물리적인 정보(예를 들면 URI)도 절대 포함해서는 안된다.


---
- 주소 공간이란?
[[OSTEP] 주소 공간의 개념](https://velog.io/@kshired/OSTEP-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84%EC%9D%98-%EA%B0%9C%EB%85%90#%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84) -> 아직 안읽어봄!!
- 프로세서와 프로세스의 차이   
👀 [프로세서와 프로세스의 차이 (processor vs process)](https://blogger.pe.kr/422)   
    - processor: 처리기   
    process: 진행, 방법
    - 프로세서는 "중앙 처리 장치" 즉 CPU를 가리키는 말이다.   
    하드웨어적인 측면에서 "컴퓨터 내에서 프로그램을 수행하는 하드웨어 유닛"
    - 프로세스는 **메모리에 로드되어 실행중이거나 대기중인 프로그램**을 말한다.

- 링킹: [클린아키텍처 12장 컴포넌트](./12-component.md) 내용 참고하기

- 동적 다형성? 정적 다형성? -> 동적 바인딩과 정적 바인딩을 의미하는 건가? 그럼 동적/정적 디스패치와는 또 무슨차이가 있는거지?🤯   
👀 [Java 다형성](https://dejavuhyo.github.io/posts/java-polymorphism/)   
👀 [다형성(Polymorphism) in Swift](https://velog.io/@budlebee/%EB%8B%A4%ED%98%95%EC%84%B1-Polymorphism-in-Swift)
    - 다형성
        - ~~동일한 타입으로 묶을 수 있는 여러 객체에게 동일한 명령을 내렸을 때 각자 다른 동작을 하는 성질.~~
        - 프로그래밍 언어의 요소가 다양한 형태를 가질 수 있는 것.
        - 예를 들어 `Person`과 `Student`라는 클래스가 있고 `Student`가 `Person`을 상속받았다면, `Student` 인스턴스는 동일한 타입의 변수나 상수뿐만 아니라 `Person` 타입의 변수나 상수에도 할당되어질 수 있다.
    - 정적 다형성
        - 컴파일 시간에 바인딩되어 런타임 시 vtable 조회를 없애는 다형성. 
        - 메소드 오버로딩이 이에 해당한다.
    - 동적 다형성
        - 런타임 시 하위클래스가 상위 형식에 할당될 때 실행할 적절한 메소드를 바인딩한다. 
        - 메소드 오버라이딩이 이에 해당한다.

- 런타임 의존성과 컴파일타임 의존성   
👀 👍 [[OOP] 의존성(Dependency)이란? 컴파일 타임 의존성과 런타임 의존성의 차이 및 비교](https://mangkyu.tistory.com/226)
    - 컴파일타임 의존성
        - 코드를 컴파일 하는 시점에 결정되는 의존성.
        - 클래스 사이의 의존성에 해당된다.
        - 추상화된 클래스나 인터페이스가 아닌 구체 클래스에 의존하면 컴파일타임 의존성을 갖게된다.
    - 런타임 의존성
        - 코드를 실행하는 시점에 결정되는 의존성.
        - 객체 사이의 의존성(클래스와 객체의 차이에 대해 인지하고 있어야 한다.)
        - 추상에 의존할 때 런타임 의존성을 갖게됨.