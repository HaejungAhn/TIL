## 들어가며

- "객체지향이란 무엇인가?"에 대한 자신만의 견해를 가지고 있는 것이 중요하다.
- 객체지향의 핵심은 클래스나 상속이 아니라 "객체"이다.

## 1. 협력하는 객체들의 공동체

#### <b>객체지향의 목표</b>
- >✓ 객체지향이란 실제 세계를 직접적이고 직관적으로 모델링할 수 있는 패러다임이다.   
✓ 객체지향이란 실제 세계를 소프트웨어 안으로 옮긴 것이므로, 객체지향 소프트웨어는 실세계의 모방이다.
- 일반적으로 객체지향에 대해 처음 접하게 되면 위와 같은 설명을 볼 수 있다.    
이 책에서는 객체지향에 대한 이러한 관점이 객체지향의 철학적 개념을 이해하기에는 적합하나, 실용적인 관점에서는 적합하지 않다고 얘기하고 있다.
- 왜냐하면 객체지향의 목표는 실제 세계를 단순히 소프트웨어에 옮기는 것이 아니라, 고객 및 사용자를 만족시킬 수 있는 새로운 세계를 창조하는 것에 있기 때문이다. (따라서 실세계의 모방이라는 전통적인 관점은 적합하지 않다는 것)
- 객체지향의 목표가 모방이 아닌 창조임에도 불구하고 이러한 비유를 사용하는 이유는 위에서도 언급했다시피 객체지향의 철학적 개념을 설명하는데 적합하기 때문이다.

#### <b>협력, 역할, 책임에 대하여</b>
- 실제 세계에서는 어떤 일을 달성하기 위해 역할/책임을 가진 사람들이 서로 협력해야 한다. 서로 필요한 것이 있으면 요청해야 하고 요청을 받은 사람은 이에 응답함으로써 협력이 이루어진다.
- 객체지향 세계에서도 마찬가지다. 어플리케이션의 특정 기능 수행을 위해 역할/책임을 가진 객체들이 서로 협력해야 한다.
- 애플리케이션의 기능은 더 작은 책임으로 분할되고 책임은 적절한 역할을 수행할 수 있는 객체에 의해 수행된다.
- **협력**
    - 참여한 객체들 사이의 요청(request)과 응답(response)로 구성된다.
- **책임**
    - 수행 해야할 일
    - 객체지향 설계의 품질을 결정하는 가장 중요한 요소로, 적절한 객체에게 적절한 책임을 할당하는 것에서 객체지향 설계가 시작된다.
- **역할**
    - 어떤 협력에 참여하는 특정 객체가 그 안에서 차지하는 책임이나 의무를 의미한다. (의미적으로 책임도 내포되어 있음)
    - 협력에 참여하는 객체에 대한 일종의 페르소나이며, 관련성 높은 책임의 집합이다.
        - 🤔 여기서 "페르소나"라는 단어를 쓴 이유는 무엇일까? 어떤 맥락으로 이해 해야할까? -> 배우들이 자유자재로 착용/미착용할 수 있는 가면이라고 이해하면 좋을 것 같다. 역할은 고정된 것이 아니라는 의미가 내포되어 있음.
- 객체는 실제 세계의 사람과 유사하게 다음과 같은 특징을 지닌다.
    - 여러 객체가 동일한 역할을 수행할 수 있다.
    - 역할은 대체 가능성을 의미한다.
    - 각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있다.
    - 하나의 객체가 동시에 여러 역할을 수행할 수 있다.

#### <b>협력 속에 사는 객체</b>
- 객체지향 애플리케이션의 **윤곽**을 결정하는 것은 역할, 책임, 협력이지만, 실제로 협력에 참여하는 것은 객체이다. 객체가 없으면 역할, 책임, 협력이 아무런 의미가 없다.
- 객체는 애플리케이션의 기능을 구현하기 위해 존재하며, 이 기능은 매우 크기때문에 필연적으로 여러 객체가 필요하고 따라서 객체 간 협력이 필요하다.
- 그렇기 때문에 객체는 아래 두가지 특성을 가지고 있어야 한다.
    - 충분히 협력적이어야 한다.
        - 충분히 협력적이라는 말은 필요할 때 다른 객체에게 요청할 수 있어야 하며, 요청을 받았을 때 응답할 수 있어야 함을 의미한다.
        - 응답을 한다고 해서 객체를 수동적인 존재로 이해하면 안된다. 외부에서 객체가 요청을 보내거나 응답을 하는 것을 다 컨트롤할 수는 없다. 객체는 요청과 응답에 대해 자율적으로 반응해야 한다.
    - 충분히 자율적이어야 한다.
        - 위와 같은 맥락에서 자율성이 나온다. 
        - 요청이 들어왔을 때 그 요청을 처리하는 방식을 결정하는 것은 객체의 자율에 맡긴다.
        - 응답을 할지 말지에 대한 것은 객체의 자율에 맡긴다.
        - 즉, 객체가 자신의 행동을 스스로 결정하고 책임지는 것이다. 
        - 이를 위해서는 객체가 스스로 상태(state)와 행동(behavior)을 가지고 있어야 한다.

#### <b>상태와 행동을 함께 지닌 자율적인 객체</b>
해당 챕터는 조금 더 곱씹어보고 소화시킬 시간이 필요해서 책에 나온 내용 그대로 기록한다.   
😮 천천히 살펴보면 이 안에 객체지향의 4가지 특성이 들어가 있다.
> 객체의 자율성은 객체의 내부와 외부를 명확하게 구분하는 것으로부터 나온다. 객체의 사적인 부분은 객체 스스로 관리하고 외부에서 일체 간섭할 수 없도록 차단해야 하며, 객체의 외부에서는 접그닝 허락된 수단을 통해서만 객체와 의사소통해야 한다. 객체는 다른 객체가 '무엇(what)'을 수행하는지는 알 수 있지만 '어떻게(how)' 수행하는지에 대해서는 알 수 없다.

> 객체의 관점에서 자율성이란 자신의 상태를 직접 관리하고 상태를 기반으로 스스로 판단하고 행동할 수 있음을 의미한다. 객체는 행동을 위해 필요한 상태를 포함하는 동시에(바리스타는 커피 제조 방법을 기억하고 있다) 특정한 행동을 수행하는 방법을 스스로 결정할 수 있어야 한다(바리스타는 자신이 알고 있는 방법에 따라 커피를 제조한다). 따라서 객체는 상태와 행위를 하나의 단위로 묶는 자율적인 존재다.

> 과거의 전통적인 개발 방법은 데이터와 프로세스를 엄격하게 구분한다. 이에 반해 객체지향에서는 데이터와 프로세스를 객체라는 하나의 틀 안에 함께 묶어 놓음으로써 객체의 자율성을 보장한다. 이것이 전통적인 개발 방법과 객체지향을 구분 짓는 가장 핵심적인 차이다. 자율적인 객체로 구성된 공동체는 유지보수가 쉽고 재사용이 용이한 시스템을 구축할 수 있는 가능성을 제시한다.

#### <b>협력과 메시지</b>
- 협력을 위해 다양한 수단으로 소통하는 사람들과는 달리, 객체들은 오로지 "메시지"를 통해서만 소통할 수 있다.
- 메시지를 전송하는 객체를 `sender`, 메시지를 수신하는 객체를 `receiver`라고 부른다.
- 😮 개발문서를 보다보면 `receiver`라는 단어가 많이 나오는데 이런 관점에서 나온 단어구나! 라는 것을 알게 됐다.


#### <b>메서드와 자율성</b>
- 객체가 수신된 메시지를 처리하는 방법을 메서드라고 부른다.
    - 😮 메시지와 메소드는 서로 다른 것이었군!
    - 요청이 메시지, 이를 처리하는 구체적인 방법이 메소드
- 객체지향 프로그래밍 언어에서 메서드는 클래스 안에 포함된 함수를 통해 구현되므로 어떤 객체에 메시지를 전송하면 이 메시지에 대응되는 특정 메소드가 실행된다.
- 메시지를 수신한 객체가 런타임 도중 메소드를 선택할 수 있다는 점은 객체지향 프로그래밍 언어를 구분 짓는 핵심 특징 중 하나다.
- 메시지와 메소드의 분리는 객체들 간 자율성을 증진시키며, 캡슐화라는 개념과도 깊이 관련돼 있다.


#### <b>객체를 지향하라</b>
- 좋은 객체지향 설계자가 되기 위한 첫번째 관문은 코드를 담은 클래스가 아닌 <u>메시지를 주고 받는 객체의 관점</u>으로 사고의 중심이 전환되는 것이다.
- 중요한 것은 "어떤 클래스가 필요한가"가 아니라 "어떤 객체들이 어떤 메시지를 주고받으며 협력하는가"이다.
- 클래스는 객체를 만들기 위한 구현 메커니즘일 뿐이다.
- 클래스의 정적인 관계가 아니라 메시지를 주고받는 객체들 간의 동적인 관계에 집중해야 한다.
- 클래스의 구조와 메소드가 아니라 **객체의 역할, 책임, 협력에 집중**하라.

## 2. 이상한 나라의 객체
> 객체지향 패러다임은 지식을 추상화하고 추상화한 지식을 객체 안에 캡슐화함으로써 실세계 문제에 내재된 복잡성을 관리하려고 한다.
- 객체란 사람이 분명하게 인지하고 구별할 수 있는 물리적인 또는 개념적인 경계를 지닌 어떤 것이다.
- 그러나 객체와 실제 세계의 유사성은 여기까지이다. 1장에서도 언급했다시피 객체지향의 목표는 모방이 아닌 창조이기 때문이다.
- 예를 들어 현실의 전등은 사람의 손길 없이는 스스로 불을 켜고 끌 수 없지만, 객체지향에서의 전등은 스스로 불을 켜고 끌 수 있다. 실제 세계보다 훨씬 능동적인 객체가 만들어지는 것이다.
- 이 책에서는 "이상한 나라의 앨리스" 중 앨리스의 키가 늘었다 줄었다 하는 이야기와 관련하여 예시를 들어준다.
- 여기서 객체는 앨리스이며, 앨리스의 키가 상태가 된다. 키(상태)를 늘리거나 줄이기 위해 버섯을 먹거나 병 속 음료를 마시거나, 토끼의 부채로 부채질을 하거나 케이크를 먹는 행동을 한다.
- 앨리스의 키가 버섯을 먹거나 하는 등의 행동으로 인해 변하게 되는 것처럼 <u>객체의 상태 역시 객체가 가지고 있는 행동에 의해 변하게 되는 것</u>이다.
- 그러나 그 행동의 결과를 결정하는 것은 상태다. 만약 앨리스의 키가 240cm인 상태에서 부채질을 하면 키는 220cm가 될 것이다. 앨리스의 키가 60cm인 상태에서 부채질을 하면 40cm가 되고 작은 문을 통과해 정원을 지나갈 수 있을 것이다.   
즉, 행동의 결과는 상태에 의존적인 것이다.

- 객체의 다양한 특성을 설명하기 위해서는 객체를 `상태(state)`, `행동(behavior)`, `식별자(identity)`를 지닌 실체로 봐야 한다.

#### <b>상태</b>
- 객체의 상태는 행동에 의해 변하지만, 행동의 결과는 결국 객체의 상태에 의존적이라는 얘기를 했었다.
- 객체의 상태는 단순히 어떤 값을 의미하는 것이 아니다. 과거의 행동에 대한 결과가 함축되어 있다. 만약 "상태"가 없었다면 우리는 객체가 한 행동들을 모두 기록해두어야 했을 것이다. 이는 매우 복잡하고 번거로우며 알아보기 힘든 방식이다. 따라서 행동의 과정과 결과를 단순하게 기술하기 위해 만들어진 것이 상태다.
#### 상태와 프로퍼티
- 모든 객체의 상태는 단순한 값과 객체의 조합으로 표현되어질 수 있는데 객체의 상태를 구성하는 모든 특징들을 통틀어 `프로퍼티(property)`라고 부른다. 일반적으로 프로퍼티는 변경되지 않고 고정되기 때문에 정적이다.
- 이와 달리 `프로퍼티 값(property value)`은 시간의 흐름에 따라 변경되기 때문에 동적이다.
- 객체의 상태를 나타내는 또다른 객체가 있을 경우(또 다른 객체를 참조할 경우) 둘 사이는 서로 연관관계가 생성된다. 이러한 연결을 `링크`라고 하며, 이게 있어야만 요청을 보내고 받을 수 있다.
- 객체를 구성하는 단순한 값은 `속성(attribute)`이라고 부른다.
- 결론적으로 프로퍼티는 단순한 값인 속성과 다른 객체를 가리키는 링크라는 두 가지 종류의 조합으로 표현할 수 있다.

#### <b>행동</b>
- 객체는 자율적인 존재이고 따라서 어떤 객체가 다른 객체의 상태에 직접 접근할 수도, 그 상태를 변경할 수도 없다.
- 따라서 간접적으로 상태를 조정할 수 있는 방법이 필요하고 이를 가능하게 하는 것이 행동이다.
- 객체가 취하는 행동은 자신의 상태를 변경시킨다. (객체의 행동이 side effect를 초래함으로써 가능한 것)
- 상태와 행동 사이에는 다음과 같은 관계가 있다.
    - 객체의 행동은 상태에 영향을 받는다.
    - 객체의 행동은 상태를 변경시킨다.
- 객체의 행동은 다음 두가지 관점에서 서술할 수 있다.
    - 상호작용이 현재의 상태에 어떤 방식으로 의존하는가
    - 상호작용이 어떻게 현재 상태를 변경시키는가
- 1장에서 객체는 섬이 아니며 협력 공동체에 참여해야 한다고 했다. 그리고 협력을 하는 방법은 요청을 받고 이에 대한 응답을 해주는 것이다.
- 객체는 오로지 행동을 통해서만 협력에 참여할 수 있다. 이 과정에서 자신의 상태 뿐만 아니라 다른 객체(링크된 객체)의 상태 변경을 유발할 수도 있다.
    - 객체 자신의 상태변경
    - 행동 내에서 협력하는 다른 객체에 대한 메시지 전송
- 객체는 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다. 객체가 외부에 노출하는 것은 행동뿐이다. 객체의 행동을 유발하는 것은 외부로부터 전달된 메시지이지만, 객체의 상태를 변경할지 말지 결정하는 것은 객체 스스로가 한다.

#### <b>식별자</b>
- 객체가 식별 가능하다 = 객체를 서로 구별할 수 있는 특정 프로퍼티가 객체 안에 존재한다는 의미. 이 프로퍼티를 식별자라고 한다.
- 값은 변하지 않는 양을 모델링한다. 값의 상태는 변하지 않기 때문에 불변상태(immutable state)를 가진다고 말한다. 값은 식별자를 가지지 않는다.
    - 🤔 "값의 상태는 변하지 않는다"가 이해가 안됨. 값은 언제든 변할 수 있는 것 아닌가..?
    - 값이 동일한지 여부는 상태가 같은지를 이용해 판단한다. 상태를 이용해 두 값이 같은지 판단할 수 있는 성질을 동등성(equality)이라고 한다.
- 객체는 시간에 따라 변경되는 상태를 포함하며, 행동을 통해 상태를 변경한다. 객체는 가변 상태(mutable state)를 가지며 따라서 식별자가 필요하다.
    - 식별자를 기반으로 두 객체가 같은지 아닌지 판단할 수 있는 성질을 동일성(identical)이라고 한다.

#### 정리
- 객체는 상태를 가지며 상태는 변경 가능하다.
- 객체의 상태를 변경시키는 것은 객체의 행동이다.
    - 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.(54p)
    - 행동의 순서가 실행 결과에 영향을 미친다.
- 객체는 어떤 상태에 있더라도 유일하게 식별 가능하다.

#### <b>행동이 상태를 결정한다.</b>
- 객체지향에 갓 입문한 사람들이 가장 쉽게 빠지는 함정은 상태를 중심으로 객체를 바라보는 것이다. (😱 나잖아.)   
상태가 아닌 행동에 초점을 맞춰야 한다.
- 그러나 상태를 먼저 결정하고 행동을 결정하는 것은 좋은 설계 방법이 아니다.
    - 상태를 먼저 결정할 경우 캡슐화가 저해됨.
    - 객체를 협력자가 아닌 고립된 섬으로 만든다.
        - 객체가 필요한 이유는 애플리케이션의 문맥 내에서 다른 객체와 협력하기 위해서다.
    - 객체의 재사용성이 저하된다.
        - 객체의 재사용성은 다양한 협력에 참여할 수 있는 능력에서 나온다.
- 협력 안에서 객체의 행동은 결국 객체가 협력에 참여하면서 완수해야하는 책임을 의미한다.

#### <b>은유와 객체</b>
- 객체지향을 현실세계의 모방이라고 보는 관점은 객체지향 분석/설계 시 실제 세계에 있는 객체를 면밀히 관찰하고 모방하여 필요한 것만 취해 소프트웨어 객체로 구현하는 과정이라고 설명한다.
- 흔히 객체지향을 현실 세계의 추상화라고도 하는데 여기서 추상화란 실제의 사물에서 자신이 원하는 특성만 취하고 필요 없는 부분을 추려 핵심만 표현하는 행위를 말한다.
- 그러나 소프트웨어의 객체는 실제 세계의 객체와 완벽히 일치하지 않는다.
- 가장 큰 차이는 능동성에 있다.(2장의 전등 예시 참고) 레베카 워프스브록은 현실의 객체보다 훨씬 더 많은 일을 할 수 있는 소프트웨어 객체의 특징을 의인화(anthropomorphism)라고 부른다.
- 현실 세계와 객체지향 세계 사이의 관계를 좀 더 정확히 설명할 수 있는 단어는 은유(metaphor)다. 현실 세계 객체를 이용한 은유를 통해 객체지향 세계의 객체를 조금 더 쉽게 설명하고 이해할 수 있다.