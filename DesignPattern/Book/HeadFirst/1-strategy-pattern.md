## 0. 들어가며
- 디자인 패턴은 프로그램을 개발하는 과정에서 빈번하게 발생하는 디자인 문제를 정리해서 상황에 따라 간편하게 적용할 수 있게 정리한 것이다.
- 이미 우리와 비슷한 문제를 겪었던 수많은 선배 개발자들이 시간과 노력을 들이고 시행착오를 겪은 끝에 가장 효과적이라고 알려진 방법들이 "패턴"이라는 이름으로 자리를 잡은 것이다.

## 1. 디자인 패턴 소개와 전략패턴

📍 해당 장의 예제는 오리 시뮬레이션 게임 시나리오다.   
- 예제의 첫 시작은 매우 간단하다.
- 오리 시뮬레이션 게임에 있는 모든 오리들은 꽥꽥거릴 수 있고 헤엄칠 수 있으므로 `Duck`이라는 슈퍼클래스에 quack()과 swim()을 구현한다.
- display()는 오리의 모양을 그리는 것인데, 모양은 오리마다 다르므로 `Duck`을 상속받은 클래스에서 별도로 구현한다.   
(책에서는 추상메소드로 만들었다고 나와있는데, Swift에서 추상메소드를 지원하지 않는 것으로 알고 있어 메소드 오버라이딩을 이용함.)
    ```Swift
    class Duck {
        func quack() {
            print("꽥꽥")
        }
        func swim() {
            print("(~~🐤~~")
        }
        func display() {}
    }

    class MallardDuck: Duck {
        override func display() {
            print("청둥오리")
        }
    }

    class ReadheadDuck: Duck {
        override func display() {
            print("아메리카흰죽지")
        }
    }

    class RubberDuck: Duck {
        override func quack() {
            print("삑삑")
        }
        override func display() {
            print("고무오리")
        }
    }
    ```

- 그런데 변경사항이 발생함!  
👩‍💼 *오리를 날 수 있도록 만들어주세요. 일주일이면 충분하겠지요?*

### 상속 이용하기
- 빠르게 개발할 수 있는 방법은 `Duck`을 상속받은 모든 오리들이 날 수 있도록 `Duck`에 fly()라는 메소드를 추가하고 기능을 구현하는 것.
- 그런데 날지 말아야 할 RubberDuck(고무오리)까지 나는 기능이 추가되어 버렸음! 이를 해결하기 위해서는 `RubberDuck` 클래스에서 fly()를 오버라이딩해야한다.

- 기능을 추가할 때 상속을 이용하면 하위클래스에 일괄적으로 적용될 수 있다는 장점이 있지만 아래와 같은 단점도 있다.
    - <u>적용되지 말아야 할 곳에도 적용</u>이 되어버린다.(이게 가장 큰 문제임. 중복코드는 여기서 파생된 문제.)   
    🤔 이는 OCP와 SRP 원칙을 위반했다고도 볼 수 있을까?
    - 따라서 오버라이딩 후 해당 클래스에 맞는 적절한 로직을 작업해줘야 한다.
    - 그런데 만약 오버라이딩 해야할 로직이 여러 클래스에 동일하게 적용해야 한다면 어떨까? 
    - 예를 들어 오리 게임 시뮬레이션에서 날지 못하는 오리 클래스가 100개 있다면? fly() 메소드를 오버라이딩하고 날지 못하도록 처리해야하는 코드가 100개가 있다는 것이다. 즉, <u>서브클래스에서 코드의 중복이 발생</u>할 가능성이 있다.
    - 또한 슈퍼클래스의 특정 메소드에 대해 어떤 것은 오버라이딩을 안하고, 어떤 것은 오버라이딩을 해서 클래스에 맞게 커스텀하게 되면 <u>메소드의 동작을 예측하기 어려워진다.</u> 그래서 하나하나 살펴보고 오버라이딩 해야함.
    - 추가적으로 실행 시(런타임 시) 특징을 바꾸기 힘들다는 단점도 있다.

- 🤔 실행 시 특징을 바꾸기 힘들다?   
    - 처음에는 잘 이해가 안갔다. 슈퍼클래스의 메소드를 오버라이딩해서 하위 클래스 특징에 맞게 로직을 짜면 되는거 아닌가? 라고 생각했기 때문임.
    - 근데 이 책에서 말하는 "실행 시" 라는 것은 컴파일 타임이 아닌 런타임을 의미하고 있었다.(뒷장을 더 읽어보니 그랬음)
        ```Swift
        class RubberDuck: Duck {
            /*..나머지 메소드 생략..*/
            override func fly() {
                print("날 수 없음🥲")
            }
        }
        ```
    - 만약 위와 같이 오버라이딩을 해두면, `RubberDuck`이 가진 특징(예를 들면 고무오리에 로켓을 달아준다던가 하는 등)이 변해도 런타임 시에 절대 날게 만들 수 없다. <u>개발자가 코드를 고치지 않는 이상.</u>

- 오케이!! 이런 단점을 확인했고 상속이 프로그램의 유연성에 그다지 좋은 영향을 미치지 않는다는 것도 알겠음. 그럼 그 다음으로 우리가 흔히 생각하는 방법이 뭘까?
- 바로 **인터페이스**를 활용하는 것임.

### 인터페이스 이용하기
- `Flyable`이라는 인터페이스를 만들고, 필요한 클래스에서만 이를 채택해서 구현할 수 있도록 만들었음. 이렇게 하면 `Duck`을 상속받은 모든 하위 클래스에 영향을 미치지 않도록 만들 수 있음!
- 하지만 인터페이스를 활용하는 것에도 단점이 존재함. 바로 인터페이스를 구현한 곳에서 코드의 중복이 발생한다는 것이다. (이 책은 자바를 기반으로 만들어졌기 때문에) 인터페이스는 기본 구현을 제공하지 않기 때문에 인터페이스를 채택한 곳에서 동일한 코드를 작성해야한다.
- ✋ Swift에서는...
    - Swift는 protocol이 인터페이스 역할을 함. 또한 extension을 활용해 protocol이 가진 메소드의 기본 구현을 만들어 둘 수 있다. 아래와 같이.
    ```Swift
    protocol Flyable {
        func fly()
    }
    extension Flyable {
        func fly() {
            print("날 수 있음")
        }
    }

    class ReadHeadDuck: Duck, Flyable {
        /*
        fly()를 별도 구현하지 않아도 컴파일 에러가 발생하지 않는다. 
        왜냐하면 extension을 통해 기본 구현이 되어 있기 때문임.
        */
    }

    let duck = ReadHeadDuck()
    duck.fly() // 콘솔에 날 수 있음이 출력됨.
    
    ```

### 🤔 다른 해결방법이 없을까?
>**✨ 디자인 원칙 1**    
애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.

>달라지는 부분을 찾아서 나머지 코드에 영향을 주지 않도록 "캡슐화" 해야한다.  
그러면 코드를 변경하는 과정에서 의도치 않게 발생하는 일을 줄이면서 시스템의 유연성을 향상시킬 수 있다.

- 이 예제에서는 "나는 것"(사실 꽥꽥거리는 것도 있지만 제외하겠음.)이 오리의 종류마다 달라져야 하는 것이기 때문에 "나는 것"을 `Duck`에서 제거, 새로운 클래스를 만든다.
- 그리고 `Duck`의 인스턴스에 행동(fly)을 할당할 수 있어야 한다.

>**✨ 디자인 원칙 2**   
구현보다는 인터페이스에 맞춰서 프로그래밍한다.

- 여기서 말하는 "구현보다는"이 어떤 의미인지 잘 와닿지 않는다. 클래스에 직접 구현하지 말라는 건가? 

>이제부터 `Duck`의 행동은 (특정 행동 인터페이스를 구현한) 별도의 클래스 안에 들어있습니다.   
그러면 `Duck` 클래스에서는 그 행동을 구체적으로 구현할 필요가 없습니다.

- 😮 위 내용을 읽어보니 해당 컨텍스트에서의 구현이란 변하는 것과 관련된 메소드를 클래스 내부에서 직접 만드는 것을 의미하는 것 같다.

- 인터페이스에 의존하도록 아래와 같이 만들 수 있다.
- 하나의 인터페이스에 날 수 있는 방법과 관련된 모든 함수들을 만들어두는 것이 아님. fly()라는 함수 하나를 두되, 날 수 있는 방법은 분리시킴.(FlyWithWings와 FlyNoWay)
- 이 지점이 기존에 가지고 있던 생각을 바꿔주는 지점인 것 같다. 만약 내가 이 책을 보지 않았더라면 인터페이스 하나에 날 수 있는 방법을 나타내는 모든 함수들을 넣어두었을 것이다.
    ```Swift
    protocol FlyBehavior {
        func fly()
    }

    class FlyWithWings: FlyBehavior {
        func fly() {
            /*나는 방법을 구현*/
        }
    }

    class FlyNoWay: FlyBehavior {
        func fly() {
            /*
            아무것도 하지 않음.
            날 수 없어요!
            */
        }
    }
    ```
- 이러한 방법을 전략 패턴이라고 한다. 
- 즉, 어떤 행동(Behavior)에 포함되는 케이스가 여러개 있을 경우 해당 행동을 별도로 분리해서 인터페이스로 만들고 각 케이스별로 인터페이스를 채택 및 구현하는 것이다. 외부에서 사용할 때는 인터페이스를 이용하며, 런타임 시 인터페이스에 들어갈 케이스를 할당함으로써 행동을 변화시킬 수 있다.

- 이 코드에서는 인터페이스(protocol)를 활용하긴 했는데 반드시 인터페이스를 이용해야하는 것은 아니다.
    >"인터페이스에 맞춰서 프로그래밍한다"라는 말은 사실 "상위 형식에 맞춰서 프로그래밍한다"라는 말입니다.
    
    >"상위 형식에 맞춰서 프로그래밍하라"는 원칙은 <u>변수를 선언할 때</u> 보통 추상클래스/인터페이스 같은 <u>상위 형식으로 선언</u>해야 한다. 객체를 변수에 대입할 때 상위 형식을 구체적으로 구현한 형식이라면 어떤 객체든 넣을 수 있기 때문이다. 그러면 변수를 선언하는 클래스에서 실제 객체의 형식을 몰라도 된다."라는 뜻으로 생각하면 됩니다.
    
    - LSP 원칙과 연관되는 것 같다. (상위타입을 하위타입으로 치환하더라도 완벽하게 동작해야 함)

- 핵심은 실제 실행 시에 쓰이는 객체가 **코드에 고정되지 않도록**(코드를 직접 변경하지 않고도 행동을 바꿀 수 있도록) 상위타입(supertype)에 맞춰 프로그래밍해서 **다형성을 활용**해야 한다는 점에 있다.

- 그렇다면 어떻게 상위타입에 특정한 하위타입을 할당할 것인가?에 대해서도 생각해봐야 한다.   


### 상위타입에 하위타입을 할당하는 방법

- **방법 1)** 생성자에서 상위타입에 직접 하위타입을 생성/할당한다.   
    ```Swift
    class Duck {
        let flyBehavior: FlyBehavior
        /*생략*/
    }

    class RubberDuck: Duck {
        init {
            flyBehavior = FlyNoWay()
        }
        /*생략*/
    }
    
    ```
    - 근데 이렇게 만들면 특정 구현에 의존하는 것과 마찬가지고, 런타임 시 행동을 변경시킬 수 없다.
    - RubberDuck 클래스는 개발자가 코드를 변경하기 전까지 날 수 없다😢

- **방법 2)** setter method를 지정한다.
    ```Swift
    extension Duck {
        func setFlyBehavior(fb: FlyBehavior) {
            flyBehavior = fb
        }
    }

    let rubber: Duck = RubberDuck()
    rubber.performFly()
    rubber.setFlyBehavior(FlyRocketPowered()) /*로켓달고 날기*/
    rubber.performFly()
    ```
    - 런타임 시 setter method(setFlyBehavior)를 호출하는 것만으로도 `RubberDuck`의 fly 행동을 바꿀 수 있다.

- **방법 3)** 의존성 주입(Dependency Injection)   
    - 의존성 주입은 내가 추가한 항목임. 이걸 보니 생각나서..!
    - 외부에서 상위타입에 들어갈 하위타입을 생성하고, 이를 넣어주는 것이다.
- 🔗 출처 : https://kimgaeun.tistory.com/2
    
    ```Swift
    //아래는 주입하지 않은 것
    class LibraryViewModel {
        var library = Library()
    }

    //아래는 의존성을 주입해준 것
    //이런 DI 방식을 Property Injection이라고 부름.
    //옵셔널로 선언될 수밖에 없기 때문에(왜냐면 모든 저장 프로퍼티가 초기화되어야 하므로) 사용시 언래핑이 필요함
    class LibraryViewModel {
        var library: Library?
    }
    let vm = LibraryViewModel()
    let library = Library()
    vm.library = library

    //아래는 Constructor Injection
    class LibraryViewModel {
        var library: Library
        
        init(library: Library) {
            self.library = library
        }
    }

    //아래는 Method Injection(=Parameter-based Injection)
    //메소드의 매개변수로 의존성을 주입
    //의존성이 딱 한번 필요한 거라면 굳이 프로퍼티로 가지고 있을 필요가 없으니까!
    //이 방법을 이용하면 method가 호출될 때마다 의존성 객체가 새롭게 생성되기 때문에 reference를 유지하지 못함. 따라서 local method scope에서만 사용가능
    protocol LibraryManager {
        func deleteAllBooks(in library: Library)
    }
    ```
    - 위와 같은 방법과 더불어 여러 라이브러리도 존재한다. 대표적으로 Swinject가 있음.

### Composition(구성)
>**✨ 디자인 원칙 3**   
상속보다는 구성을 활용한다.

- 📒 구성 : 몇가지 부분이나 요소들을 모아 일정한 전체를 짜 이룸.
- 구성이란,,   
    - "A에는 B가 있다" 즉, "Duck 클래스에는 FlyBehavior가 있다"의 관계를 구성(Composition)이라고 한다.
    - 어찌보면 의존관계인듯? A가 B에 의존하고 있다.

