## 6장. 커맨드패턴

### 들어가며
- 메소드 호출 캡슐화하기
- 원하는 것을 적어서 넣기만 하면 간단하게 처리할 수 있다.
- 어떤 객체가 어떻게 처리하는지에 대해서는 전혀 신경 쓸 필요가 없다.

#### <b>예제 시나리오</b>
- IoT 리모컨 만들기
- 리모컨에는 7개의 슬롯이 있으며 슬롯에 할당된 기능을 켜고 끄는 on/off 버튼을 가지고 있다.
- 슬롯은 서로 다른 가정용 기기에 연결할 수 있으며 추후 더 많은 기기들이 연결될 가능성이 있으므로   
확장 가능하게 만들어야 한다.

#### <b>처음에는 이렇게 생각했다.</b>
- 커맨드 패턴을 모르는 지금은 만들게 되면 아래와 같이 만들 것 같다.
- on, off 기능을 가진 인터페이스(protocol)를 정의하고 조명, 오디오 등의 가정용 기기 클래스들이 서로 동일한 상위타입으로  
묶여질 수 있도록 만든다.
- 그리고 클라이언트에서 상위타입이 가지고 있는 메소드를 호출한다.

- 🤔 <b>이 방식의 문제점은?</b>
    - 인터페이스의 메소드 시그니처가 변경되면, 가정용 기기 클래스의 수만큼 수정이 필요하며 이를 사용하고 있는 곳에도 수정이 필요하다.
    - 인터페이스의 메소드가 추가되면 가정용 기기 클래스의 인터페이스에도 변경이 필요하다.
    - 인터페이스 중 필요없는 기능들에 대해서도 (어쨌든) 코드를 가지고 있긴 해야한다.
    - 모든 가정용 기기 클래스가 on/off 기능을 가지고 있는 것은 아니다. 예를 들어 창고 문에 대한 IoT 기기는 up/down/stop의 기능을 가지고 있는데 이 경우 별개의 인터페이스를 만들어 사용해야할 수도 있다. 큰 역할만 놓고 보면 비슷한 것들이 여러개 생기는 것이다.


#### <b>커맨드 패턴</b>
- 📒 Command 🄽 명령
- **요청 내역을 객체로 캡슐화해서 객체를 서로 다른 요청 내역에 따라 매개변수화할 수 있음.**
- 커맨드 객체는 일련의 행동을 특정 리시버와 연결함으로써 요청을 캡슐화한 것이다. 밖에서 볼 때는 어떤 객체가 리시버 역할을 하는지, 그 리시버가 어떤 일을 하는지 알 수 없다.

#### 이 책에서는 위 시나리오와 더불어 좀 더 쉬운 예시를 들어주었는데 바로 식당에서 주문하는 과정이다. 이를 커맨드 패턴과 연관지어 소개함.
- 식당에서 주문하는 과정에 필요한 객체들은 다음과 같다.
    - 손님(Client) : 주문서를 만들어 종업원에게 알려준다.
    - 주문서(Command) : 누가 이 주문을 처리해야하는지 알고 있다. 
        - 여러개의 concrete 주문서가 있다.(바리스타용 주문서, 제빵사용 주문서 등)
        - 각 concrete 주문서는 이 주문서를 받을 receiver가 누구인지 알고 있고, 어떤 순서대로 주문을 처리해야하는지 알고 있다.
    - 종업원(Invoker) : 주문서를 받으면 이를 처리해달라고 요청한다.
        - 📒 Invoker 🄽 호출자, Invoke 🅅 부르다.
    - 바리스타(BaristaReceiver) : 커피 만드는 구체적인 방법을 알고 있다.
    - 제빵사(BakerReceiver) : 빵 만드는 구체적인 방법을 알고 있다.

- 과정은 다음과 같다.
    - ✋ 이 식당은 김밥천국처럼 주문서에 나의 주문을 체크하는 시스템이다 !
    - 손님(Client)이 커피를 선택하고 주문서(Command)를 작성한다.
    - 손님이 종업원을 불러 주문서를 건낸다.
    - 종업원은 (누구에게 요청하는지는 모르겠으나) 주문서를 처리해달라고 요청한다.

- 이걸 코드로 작성해보면 다음과 같다.
    ```Swift
    class BaristaReceiver {
        // 커피 만드는 방법을 알고 있는 객체
    }
    
    protocol Command {
        func execute()
    }

    class CoffeCommand: Command {
        let receiver: BaristaReceiver
        
        init(receiver: BaristaReceiver) {
            self.receiver = receiver
        }
        
        func execute() {
            receiver.dropShot()
            ..생략..
        }
    }
    
    class Invoker {
        var command = Command()
        init() {}
        
        func setCommand(_ command: Command) {
            self.command = command
        }
        
        func requestOrder() {
            command.execute()
        }
    }

    class Client {
        let waiter = Invoker()
        
        func orderCoffee() {
            let barista = BaristaReceiver()
            let coffeeOrder = CoffeCommand(receiver: barista)
            waiter.setCommand(coffeeOrder)
            waiter.requestOrder()
        }
    }
    
    
    ```

---
커맨드 패턴은 내용이 많아 2주에 걸쳐 진행하기로 했다. 오늘은 2주차 내용에 대해 정리하고 전체적으로 복습할 예정이다.
#### <b>✍️ 리마인드</b>
- 책을 읽기 전 지난주에 봤던 커맨드 패턴의 기본 내용에 대해 리마인드 해봤는데 `Invoker`가 왜 존재하는지에 대해 잘 모르고 있었다.(왜냐하면 커맨드 패턴을 이해했다기 보다는 어떻게 생겼는지 모양새만 외웠기 때문이다..!)   
- `Invoker`는 왜 필요한걸까? `Invoker`의 형태를 살펴보자.
    - 이 책의 예제에서는 RemoteControl 클래스가 `Invoker`의 역할을 한다.
    - RemoteControl 클래스는 다음 프로퍼티, 메소드를 가지고 있다.
        - 외부에서 만들어진 Command 인스턴스들을 소유하고 있음.
        - 따라서 Command 타입 프로퍼티를 매개변수로 받아 프로퍼티에 할당할 수 있는 setter 메소드가 있음.
        - Command 인스턴스의 특정 메소드가 호출될 수 있도록 하는 인터페이스를 가지고 있음.   
            • onButtonWasPushed, offButtonWasPushed 등   
            • **따라서 클라이언트는 Concrete Command 객체의 구체적인 행동(메소드)에 대해 알 필요가 없음.**
    - 만약 `Invoker`가 없다면 클라이언트에서 Concrete Command 객체의 구체적인 메소드에 대해 알아야 한다. command 객체의 메소드가 변경(추가, 수정, 삭제)될 때마다 클라이언트 코드가 변해야하는 것이다.
    - `Invoker`는 Command를 캡슐화고, 클라이언트가 인터페이스에 맞춰 프로그래밍할 수 있도록 하며, 느슨한 결합을 사용할 수 있도록 하고 추상화된 것에 의존할 수 있도록 만드는 역할을 한다.

- 🤔 근데 이렇게 쓰다보니 책에서 나오는 객체지향 원칙에 대해 내가 너무 뭉뜽그려 알고 있다는 생각이 들었다.
    - 캡슐화, 다형성이나 느슨한 결합에 대해 설명할 수 있는가
    - OCP에서 말하는 확장과 변경이란 정확히 어떤 케이스를 말하는지 예시를 들어 설명할 수 있는가
    - 객체지향에서 말하는 추상화의 구체적인 예시를 설명해볼 수 있는가
    - Composition이 뭔지 알고 있는가, 왜 상속보다 구성을 사용해야하는지 설명할 수 있는가
        - Composition에 대해서는 [UML 다이어그램의 Relation](https://github.com/HaejungAhn/TIL/blob/main/CS/UML.md)에 대해 공부하며 조금 더 잘 이해할 수 있게 됐다.
- 다음주부터 위 질문에 대해 하나씩 클리어해야겠다!
---

#### <b>Q&A</b>
- >Q1. 항상 리시버가 필요한가요? 커맨드 객체에서 execute()를 구현하면 안 되나요?
    - Receiver: 실제 행동이 처리되는 곳. Command 객체에서 Receiver의 특정 메소드를 호출하도록 구현되어 있음.(행위의 본래 로직은 Receiver 안에 있는 것)
    - ~~위 질문은, 어차피 Command 객체 안에 Receiver의 참조를 가지고 있으니 그냥 Command의 execute()에서 Receiver를 이용해 직접 로직을 구현하면 안되냐는 질문인 것으로 보인다.(왜 또 한번 다른 메소드를 호출하냐)~~   
    (책에 나온 예제를 모두 잊어!!) "Command 객체에서 바로 처리 로직을 만들면 안되냐"라는 의미라고 이해함.
    - 여기서 말한 "커맨드 객체에서 execute()를 구현하면 안되나요?"가 어떻게 구현하는 걸 말하는지 명확하지가 않은 것 같다.
        - ~~Receiver가 가지고 있던 로직을 밖으로 꺼내겠다는 것인지~~
        - ~~execute()에서 Receiver를 생성 후 처리하겠다는 것인지 -> 근데 이렇게 되면 상태를 가지고 있지 않기 때문에 문제가 발생할 수도?~~
        - Receiver 객체가 아예 없다고 생각하면 됨. 그냥 어떤 로직을 처리하는  라인들만 있다! 라고 생각하면 됨.
- >A1. 커맨드 객체에서 대부분의 행동을 처리하게 되면 `Invoker`와 `Receiver`를 분리하기 어렵고, `Receiver`로 커맨드를 매개변수화할 수 없다.
    - 커맨드 객체에서 대부분의 행동을 처리: 위 질문에 나온 내용
    - `Invoker`와 `Receiver`를 분리하기 어렵다: `Invoker`인 `RemoteControl` 클래스 내부를 보면 Command 객체만 넘기고 있을 뿐 Receiver는 그 어디에도 없음.(244P) 만약 Command 객체에서 Receiver를 통하지 않고 그대로 처리하게 된다면,... Command가 곧 Receiver(실제 행동을 처리하는 역할)이기 때문에 그런 것인가? 
    - `Receiver`로 커맨드를 매개변수화할 수 없다: 여기서 말하는 커맨드는 명령 그 자체를 의미하는 것 같음. Receiver의 역할은 일련의 메소드, 로직들을 객체화한 것이라고 볼 수 있을 것 같다. 로직 자체를 매개변수로 넘길 수가 없잖아? 그래서 위와 같이 설명한 것 아닐까?


- >커맨드로 컴퓨테이션(Computation)의 한 부분(리시버와 일련의 행동)을 패키지로 묶어서 일급 객체 형태로 전달할 수도 있습니다. 그러면 클라이언트 애플리케이션에서 커맨드 객체를 생성한 뒤 오랜 시간이 지나도 그 컴퓨테이션을 호출할 수 있습니다. 심지어 다른 스레드에서 호출할 수도 있습니다.
    - 컴퓨테이션의 의미
        - 주어진 입력으로부터 문제의 해법을 찾는 것
    - 일급 객체
        - 함수형 프로그래밍 개념에 대해 공부할 때 "함수형 프로그래밍은 함수를 일급객체(First-class citizen)로 취급한다"는 내용을 보고 찾아보게 됐던 내용이다.
        - 일급 객체란 ① 함수의 매개변수로 전달 가능하고 ② 함수의 리턴 타입으로 사용 가능하며 ③ 변수나 상수의 타입으로 사용할 수 있는 것을 말한다.
        - 복습을 위해 기록해봄 !
    - 어떻게 클라이언트에서 오랜시간이 지나도 그 컴퓨테이션을 호출할 수 있다는 거지?
    - "심지어 다른 스레드에서 호출할 수도 있습니다" 원래는 다른 스레드에서 호출할 수 없었다는 건가?
    - 스케줄러, 스레드풀, 작업 큐

#### <b>커맨드 패턴 더 활용하기</b>
- 어떤 어플리케이션은 모든 행동을 기록해 두었다가 애플리케이션이 다운되었을 때 그 행동을 다시 호출해서 복구할 수 있어야 한다. 커맨드 패턴을 사용하면 이런 기능을 구현할 수 있다.?!
    - How?
    - 커맨드 패턴의 어떤 구조로 인해 이게 가능하다는 건지? 커맨드 패턴 이외에 다른 패턴들은 이게 불가능하다는 건지?
- 자바에서는 이런 기능을 하는 메소드를 "객체 직렬화"로 구현할 수도 있지만, 직렬화와 관련된 제약 조건때문에 그리 쉽지 않다.
    - 객체 직렬화
    - 직렬화와 관련된 제약조건?

#### <b>실전 적용! 커맨드 패턴</b>
- 자바 스윙 예제가 2장에 나옴. 2장의 주제는 옵저버 패턴이었는데 옵저버 패턴 뿐만 아니라 커맨드 패턴도 적용되어 있다고 함.
- 예시 코드 다시 한번 살펴보기
- Swift에서도 커맨드 패턴을 확인해볼 수 있지 않을까?

#### <b>핵심 정리</b>
- 커맨드 패턴을 이용하면 요청하는 객체(Invoker??)와 요청을 수행하는 객체(Receiver)를 분리할 수 있다.
- 커맨드 객체는 행동이 들어있는 Receiver를 캡슐화한다.
- 커맨드는 Invoker를 매개변수화 할 수 있다. ??? 실행중에 동적으로 매개변수화를 설정할 수도 있다.
- 요청을 스스로 처리하는 스마트 커맨드 객체 -> 내가 이해하기로는 Receiver를 통하는 것이 아니고, 커맨드 객체 내부에 요청을 처리하는 로직이 들어가 있는 것으로 이해함.


---
- 이건 번외인데, 내가 몰입할 수 있는 방법 중 하나를 오늘 발견했다. 바로 스스로 질문을 해보는 것이다.

- 오늘 커맨드 패턴에 대한 정리를 시작하기가 조금 어려웠다. 
    - 보기 좋게 정리하고 싶은데, 내용을 보긴 했지만 어떻게 정리해야할지 머릿속에 잘 그림이 그려지지 않아서였음.
- 일단 해보자! 라는 마음으로 내용을 써내려가다보니 내가 모르는 것들을 한번 더 체크할 수 있었고 질문들을 만들어낼 수 있었다.
- 그리고 이걸 하나씩 해결해가다보니 자연스레 몰입이 됐다. 앞으로도 자주 써먹어봐야지 !



