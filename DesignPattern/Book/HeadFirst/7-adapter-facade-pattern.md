## 7. Adapter패턴과 Facade패턴
 
#### 👋 <b>들어가며</b>
- 요즘 "객체지향의 오해와 사실"이라는 책을 읽고 있다. 그 책에는 객체들이 어떤 context(협력)에서 어떤 역할과 책임을 가지고 있는지를 보라고 했는데 앞으로 그런 관점에서 디자인패턴의 내용을 보면 좋을 것 같다.
- 📒 Adapter    
🄽 기계, 기구 등을 다목적으로 사용하기 위한 부가기구. 또는 그것을 부착시키기 위한 보조기구
- 📒 Facade   
🄽 (건물의) 정면, (실제와는 다른) 표면
- 두 패턴이 한 챕터에 들어간 이유는 둘 다 ~하는 척 하도록 만들어주기 때문이다.

#### <b>Adapter 패턴</b>
- 일본이나 홍콩으로 여행을 가면 꼭 챙겨가야 하는게 있다. 바로 어댑터(a.k.a 돼지코)다. 우리나라는 콘센트에 2개의 동글동글한 인터페이스를 사용하지만 일본은 2개의 얇고 네모난 인터페이스를, 홍콩은 3개의 인터페이스를 사용하기 때문에 어댑터 없을 경우 우리나라 제품을 충전시킬 수 없다.
- Adapter 패턴은 위의 어댑터와 동일한 역할을 한다. 서로 다른 인터페이스를 가진 두 객체에 어떠한 변경 없이 정상적으로 연결되어 사용할 수 있도록 한다.
- 책에서는 Adapter 패턴과 관련된 역할이 3개가 나온다.
    - `Adapter` 기존과 다른 인터페이스를 가진 새로운 클래스가 기존 코드와 잘 연결되도록 중개해야 할 책임이 있다.
    - `Adaptee` 기존과 다른 인터페이스를 가진 새로운 클래스
    - `Target Interface` 기존 인터페이스

- Adapter 패턴의 정의
    - 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환한다.
    - 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있게 도와준다.
    - 언제 사용하나요?
        - 기존과 다른 인터페이스를 가진 클래스를 코드 변경 없이 사용 해야할 때 유용하다.
- Adapter 패턴의 장점
    > 클라이언트와 구현된 인터페이스를 분리할 수 있으며, 
    - 클라이언트는 Adaptee의 메소드를 호출할 필요가 없다. 기존 인터페이스만 호출하면 됨.
    > 변경 내역이 어댑터에 캡슐화되기에 나중에 인터페이스가 바뀌더라도 클라이언트를 바꿀 필요가 없습니다.

- Adapter 패턴을 구현할 때 composition을 사용하기 때문에(Adapter가 Adaptee를 프로퍼티로 가지고 있음) Adaptee의 모든 서브클래스가 기존 Adapter를 계속 사용할 수 있다.

- Adapter 패턴을 조금 더 쪼개보면 객체 어댑터와 클래스 어댑터로 나뉜다.
    - 객체 어댑터는 Adaptee를 프로퍼티로 가지고 있는 형태이며, 클라이언트에서 기존에 사용하던 인터페이스가 `Protocol` 타입이다.
    - 클래스 어댑터는 클라이언트에서 기존에 사용하던 인터페이스가 `class`인 경우 다중 상속을 통해 구현이 가능하다.
    - 클래스 어댑터의 경우 상속을 통해 어댑터가 만들어지기 때문에 서브클래스가 추가될 경우 새로운 어댑터를 만들어야 한다.
    - 클래스 어댑터의 단점은 특정 Adaptee 클래스에만 적용할 수 있다는 것이며 장점은 Adaptee 전체를 (강제로) 다시 구현할 필요가 없다는 것.


#### <b>Facade 패턴</b>
- 인터페이스를 단순화하기 위해 사용하는 패턴이다.
- Facade라는 이름은 표면의 의미를 가지고 있는데 하나 이상의 클래스 인터페이스를 깔끔하면서도 효과적인 표면, 껍데기로 덮어주기 때문에 붙여진 이름이다.
- Facade 패턴과 관련된 역할
    - `서브시스템들` 클라이언트에게 다양한 기능을 제공하는 여러 객체들. 하나의 기능을 제공하기 위해 서브시스템에 포함되는 객체들의 특정 행동을 일정한 순서대로 호출해야 한다.
    - `Facade` 클라이언트가 Facade의 특정 인터페이스를 호출하기만 하면 그 기능이 동작되도록 해야한다.
- Facade 클래스의 장점
    - 서브시스템 클래스를 캡슐화하지 않기 때문에 클라이언트가 필요로 한다면 서브 시스템의 모든 기능을 사용할 수 있도록 만들어준다.
    - 클라이언트 구현과 서브시스템을 분리할 수 있다.
- 데코레이터/어댑터/퍼사드 패턴의 차이
    - 어댑터 패턴은 인터페이스를 변경해서 클라이언트에서 필요로 하는 인터페이스로 적응시키는 용도
    - 퍼사드 패턴은 어떤 서브시스템에 대한 간단한 인터페이스를 제공하는 용도
    - 데코레이터 패턴은 인터페이스를 바꾸지 않고 책임만 추가하는 용도

#### <b>최소 지식 원칙(데메테르 법칙)</b>
- 객체 사이의 상호작용은 될 수 있으면 아주 가까운 '친구' 사이에서만 허용하는 편이 좋다.(상호작용하는 객체는 최소한으로 하라)
- 친구를 만들지 않고 다른 객체에 영향력 행사하는 방법
    - 객체 자체(자기 자신이 가지고 있는 메소드를 사용)
    - 메소드에 매개변수로 전달된 객체
    - 메소드 내에서 생성된 객체
    - 객체에 속하는 구성요소(인스턴스 변수에 의해 참조되는 객체)
- 아래는 메소드를 호출한 결과로 리턴받은 객체에 들어있는 메소드를 호출할 때이며, 이 경우 다른 객체의 일부분에 요청을 하게 되고 직접적으로 알고 지내는 객체의 수가 늘어나게 된다.
    ```Swift
    func getTemp() -> Float {
        return station.getThermometer().getTemperature()
    }
    ```
- 위 코드를 최소 지식 원칙에 맞게끔 바꾸기 위해서는 station 변수의 타입에 새로운 메소드를 추가해야 한다.
    ```Swift
    func getTemp() -> Float {
        return station.getTemperature()
    }
    ```
- 이 원칙을 잘 사용하면 객체 사이의 의존성을 줄일 수 있고 소프트웨어 관리가 편해진다. 하지만 메소드 호출을 처리하는 래퍼 클래스를 더 만들어야 할 수 있기 때문에 시스템의 복잡도와 개발 시간이 늘어날 수 있다. 성능도 떨어질 수 있다(고 하는데 왜 그런지는 이해 못함)